"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[5150],{7237:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>n,toc:()=>d});const n=JSON.parse('{"id":"frontend/angular/design-patterns/behavioural-patterns/strategy","title":"Strategy","description":"Use case: Implementing different algorithms or strategies that can be switched at runtime.","source":"@site/docs/frontend/angular/design-patterns/behavioural-patterns/strategy.md","sourceDirName":"frontend/angular/design-patterns/behavioural-patterns","slug":"/frontend/angular/design-patterns/behavioural-patterns/strategy","permalink":"/av-docs/docs/frontend/angular/design-patterns/behavioural-patterns/strategy","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/angular/design-patterns/behavioural-patterns/strategy.md","tags":[],"version":"current","frontMatter":{},"sidebar":"devopsSidebar","previous":{"title":"State","permalink":"/av-docs/docs/frontend/angular/design-patterns/behavioural-patterns/state"},"next":{"title":"Template Method","permalink":"/av-docs/docs/frontend/angular/design-patterns/behavioural-patterns/template-method"}}');var i=a(4848),r=a(8453);const s={},o="Strategy",l={},d=[];function c(e){const t={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"strategy",children:"Strategy"})}),"\n",(0,i.jsx)(t.p,{children:"Use case: Implementing different algorithms or strategies that can be switched at runtime."}),"\n",(0,i.jsx)(t.p,{children:"Example: Using different validation strategies in reactive forms."}),"\n",(0,i.jsx)(t.p,{children:"How to find: Search for classes or functions that implement a common interface but with different logic."}),"\n",(0,i.jsx)(t.p,{children:"Explanation:"}),"\n",(0,i.jsx)(t.p,{children:"The Strategy pattern allows selecting an algorithm's behavior at runtime. You define a family of algorithms, encapsulate each one, and make them interchangeable. In Angular, you might switch between different validation strategies or sorting algorithms based on user input or configuration."}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:"// validation-strategy.interface.ts\nexport interface ValidationStrategy {\n  validate(value: any): boolean;\n}\n\n// required-validation.strategy.ts\nimport { ValidationStrategy } from './validation-strategy.interface';\n\nexport class RequiredValidationStrategy implements ValidationStrategy {\n  validate(value: any): boolean {\n    return value !== null && value !== undefined && value !== '';\n  }\n}\n\n// email-validation.strategy.ts\nimport { ValidationStrategy } from './validation-strategy.interface';\n\nexport class EmailValidationStrategy implements ValidationStrategy {\n  validate(value: any): boolean {\n    const emailRegex = /^\\S+@\\S+\\.\\S+$/;\n    return emailRegex.test(value);\n  }\n}\n\n// validator.service.ts\nimport { Injectable } from '@angular/core';\nimport { ValidationStrategy } from './validation-strategy.interface';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ValidatorService {\n  private strategy: ValidationStrategy;\n\n  setStrategy(strategy: ValidationStrategy) {\n    this.strategy = strategy;\n  }\n\n  validate(value: any): boolean {\n    return this.strategy.validate(value);\n  }\n}\n\n// dynamic-form.component.ts\nimport { Component } from '@angular/core';\nimport { ValidatorService } from './validator.service';\nimport { RequiredValidationStrategy } from './required-validation.strategy';\nimport { EmailValidationStrategy } from './email-validation.strategy';\n\n@Component({\n  selector: 'app-dynamic-form',\n  template: `\n    <input [(ngModel)]=\"inputValue\" />\n    <button (click)=\"useRequiredValidation()\">Use Required Validation</button>\n    <button (click)=\"useEmailValidation()\">Use Email Validation</button>\n    <div>Is Valid: {{ isValid }}</div>\n  `,\n})\nexport class DynamicFormComponent {\n  inputValue: string;\n  isValid: boolean;\n\n  constructor(private validatorService: ValidatorService) {}\n\n  useRequiredValidation() {\n    this.validatorService.setStrategy(new RequiredValidationStrategy());\n    this.validate();\n  }\n\n  useEmailValidation() {\n    this.validatorService.setStrategy(new EmailValidationStrategy());\n    this.validate();\n  }\n\n  validate() {\n    this.isValid = this.validatorService.validate(this.inputValue);\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"ValidationStrategy interface defines the validation method."}),"\n",(0,i.jsx)(t.li,{children:"Different strategies (RequiredValidationStrategy, EmailValidationStrategy) implement this interface."}),"\n",(0,i.jsx)(t.li,{children:"ValidatorService uses the selected strategy to validate input."}),"\n",(0,i.jsx)(t.li,{children:"DynamicFormComponent switches strategies at runtime based on user actions."}),"\n"]})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,a)=>{a.d(t,{R:()=>s,x:()=>o});var n=a(6540);const i={},r=n.createContext(i);function s(e){const t=n.useContext(r);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),n.createElement(r.Provider,{value:t},e.children)}}}]);