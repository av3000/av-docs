"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[4382],{4123:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"frontend/testing/index","title":"Frontend Testing","description":"To ensure that you stick to the best practices of frontend testing, you need a framework to follow. Luckily, you can use the F.I.R.S.T. principles for it.","source":"@site/docs/frontend/testing/index.md","sourceDirName":"frontend/testing","slug":"/frontend/testing/","permalink":"/av-docs/docs/frontend/testing/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/testing/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"frontendSidebar","previous":{"title":"Intro","permalink":"/av-docs/docs/frontend/"},"next":{"title":"Component Testing","permalink":"/av-docs/docs/frontend/testing/component-testing/"}}');var i=t(4848),o=t(8453);const a={},r="Frontend Testing",c={},l=[{value:"Testing Pyramid",id:"testing-pyramid",level:2},{value:"Types of Testing",id:"types-of-testing",level:2},{value:"Unit Test",id:"unit-test",level:3},{value:"Component Test",id:"component-test",level:3},{value:"4 Reasons Component Testing is Hard ( In Angular)",id:"4-reasons-component-testing-is-hard--in-angular",level:4},{value:"Component testing vs Cypress component testing",id:"component-testing-vs-cypress-component-testing",level:4},{value:"End-to-End(E2E) Test",id:"end-to-ende2e-test",level:3},{value:"Acceptance testing",id:"acceptance-testing",level:3},{value:"Visual regression testing",id:"visual-regression-testing",level:3},{value:"Accessibility testing",id:"accessibility-testing",level:3},{value:"Performance testing",id:"performance-testing",level:3},{value:"Integration testing",id:"integration-testing",level:3},{value:"Cross-browser testing",id:"cross-browser-testing",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"frontend-testing",children:"Frontend Testing"})}),"\n",(0,i.jsx)(n.p,{children:"To ensure that you stick to the best practices of frontend testing, you need a framework to follow. Luckily, you can use the F.I.R.S.T. principles for it."}),"\n",(0,i.jsx)(n.p,{children:"F.I.R.S.T. principles stand for:"}),"\n",(0,i.jsx)(n.p,{children:"Fast\nIsolated/Independent\nRepeatable\nSelf-validating\nThorough"}),"\n",(0,i.jsx)(n.p,{children:"Most of these are self-explanatory. Tests should be run speedily (at any necessary point of the life cycle), isolated from untested components, easily repeatable for the future, able to validate themselves whether the test has been passed and cover all necessary variables.\nFailing test is a starting point where you have a test you need to pass."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"types-of-frontend-testing",src:t(3665).A+"",width:"646",height:"315"})}),"\n",(0,i.jsx)(n.p,{children:"Use real browsers and devices"}),"\n",(0,i.jsx)(n.p,{children:"Using real browsers and devices is an essential aspect of conducting error-free, reliable frontend tests which reflect the real-world environment as much as possible. Avoid using emulators and simulators and save time and resources by using real browsers and devices - this way, you will be able to rely on your software testing results much more."}),"\n",(0,i.jsx)(n.p,{children:"Types of frontend tests"}),"\n",(0,i.jsx)(n.p,{children:"Since there are different elements to test for the frontend, there are a few different types of tests you can consider running. Each of these focuses on a different component of your frontend and together will ensure successful frontend testing for your application."}),"\n",(0,i.jsx)(n.h2,{id:"testing-pyramid",children:"Testing Pyramid"}),"\n",(0,i.jsx)(n.p,{children:"The testing pyramid is a framework to help development teams create high-quality software. It reduces the time needed for developers to identify any changes negatively impacting their code and supporting building reliable test suites.\nIt is sometimes referred to as the \u2018 test automation pyramid\u2019. It sets out the test types that you should include in automated testing and outlines what sequences and frequency these tests should follow. The aim is to provide immediate feedback, ensuring that code changes do not disrupt existing features."}),"\n",(0,i.jsx)(n.p,{children:"There are 3 main categories of testing:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"testing-pyramid",src:t(3353).A+"",width:"449",height:"430"})}),"\n",(0,i.jsx)(n.p,{children:"Structure of software tests to ensure reliable, efficient, and scalable testing practices.\nIt provides a clear guideline on how to distribute different types of tests in a project to achieve high test coverage with minimal maintenance costs."}),"\n",(0,i.jsx)(n.h2,{id:"types-of-testing",children:"Types of Testing"}),"\n",(0,i.jsx)(n.h3,{id:"unit-test",children:"Unit Test"}),"\n",(0,i.jsx)(n.p,{children:"Unit testing is the fundamental building block of frontend testing. It analyzes individual components and functions to ensure they\u2019re working as expected. This is crucial for any frontend application, testing your components and features against how you expect them to behave in production, leading to a stable codebase and a reliable app for your customers. You can also use unit testing for things like edge cases and testing APIs."}),"\n",(0,i.jsx)(n.p,{children:"Unit test is something when we instantiate the class on our own inside our test we're calling new class that we pass on the mocked version of dependencies and we test the class itself. No DOM interaction and no testbed(Angular), just basic individual units or functions in isolation, focusing on a small part of the code."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"helper function to transform value to display-friendly value"}),"\n",(0,i.jsx)(n.li,{children:"validator function to check if email is valid"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast to write and execute."}),"\n",(0,i.jsx)(n.li,{children:"High in volume, covering the majority of the codebase."}),"\n",(0,i.jsx)(n.li,{children:"Cheap to maintain since they only focus on a single unit of functionality."}),"\n",(0,i.jsx)(n.li,{children:"Ensure correctness of functions, methods, or classes in isolation from external dependencies."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"component-test",children:"Component Test"}),"\n",(0,i.jsx)(n.p,{children:"Component test has a testbed(Angular), the DOM interaction, focuses on testing individual components (often UI components or logical groupings of code) and their interactions with other components or dependencies ensuring component behaves as expected when iteracting with surounded components or services."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"service layer interaction with a database"}),"\n",(0,i.jsx)(n.li,{children:"component UI element event is triggered after button clicked and event was dispatched"}),"\n",(0,i.jsx)(n.li,{children:"component loading state was dispatched and displayed correctly after loading completed"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Slightly slower and more expensive than unit tests but faster than E2E tests."}),"\n",(0,i.jsx)(n.li,{children:"Can include testing at the component level (for example, React components) or the integration between different modules."}),"\n",(0,i.jsx)(n.li,{children:"Verifies that a set of units interact correctly, typically including some level of dependency (like services, databases, or APIs)."}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"4-reasons-component-testing-is-hard--in-angular",children:"4 Reasons Component Testing is Hard ( In Angular)"}),"\n",(0,i.jsx)(n.p,{children:"Mostly all reasons happen because of the need to handle manually processing which in application code are handled for us."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Configuration of testing module.\nIts something that we cannot just simply eliminate, we cannot automatize it, because we need to define which dependencies we want and do not want to mock. The complexity comes from Angular itself because we need to know about relationship of components, how services behave, what is it providing and other possible dependencies."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Asynchrony.\nIn our test we have to know at which lines of code internally triggering asynchronous tasks because inside of our test we need to manage them, we need to use fakeAsync together with tick or similar approach where we acknowledge the existing async tasks running, run them now synchronously and then we continue.\nIn the application code it works, but in tests we are the ones to manage it."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"DOM Interaction.\nIn application code it is handled and works fine, but it causes troubles in our tests depending on how many components we use in one particular test, because some components listen to DOM events to be triggered to work properly."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Change Detection.\nWe have to trigger it manually ",(0,i.jsx)(n.code,{children:"Fixture.detectChanges"})," otherwise the HTML or the DOM is not up-to-date.\nThere is an option to set change detection automatically, but still it will not work on all situations."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"component-testing-vs-cypress-component-testing",children:"Component testing vs Cypress component testing"}),"\n",(0,i.jsx)(n.p,{children:"Testing of components can be done in conventional way either using native methods or 3rd party libraries or with E2E tool like Cypress."}),"\n",(0,i.jsx)(n.p,{children:"Component Tests:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Can be tested in isolation"}),"\n",(0,i.jsx)(n.li,{children:"We have precision & control"}),"\n",(0,i.jsx)(n.li,{children:"Fast execution"}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Requires TestBed Setup of all dependencies and other related components with their dependencies"}),"\n",(0,i.jsx)(n.li,{children:"Requires to manage asynchrony"}),"\n",(0,i.jsx)(n.li,{children:"Requires to manage change detection"}),"\n",(0,i.jsx)(n.li,{children:"Requires to simulate DOM interaction"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Component Tests with E2E"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Can be tested in isolation"}),"\n",(0,i.jsx)(n.li,{children:"We have precision & control"}),"\n",(0,i.jsx)(n.li,{children:"No asynchrony management"}),"\n",(0,i.jsx)(n.li,{children:"No change detection management"}),"\n",(0,i.jsx)(n.li,{children:"Great developer experience ( Browser feedback, screenshots, video recording, tasks/network stubbing)"}),"\n"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Requires major infrastructure"}),"\n",(0,i.jsx)(n.li,{children:"Slow speed of execution"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"end-to-ende2e-test",children:"End-to-End(E2E) Test"}),"\n",(0,i.jsxs)(n.p,{children:["End-to-end testing is used to check and confirm that ",(0,i.jsx)(n.a,{href:"https://www.netguru.com/blog/e2e-testing-vs-integration-testing",children:"the flow of the application"})," works as expected from start to finish. It is mainly done by mimicking the actions of a real user within real-world scenarios to ensure smooth communication between the application\u2019s interface and API is running smoothly. Doing so provides insight into the combined behavior of multiple system elements coupled together."]}),"\n",(0,i.jsx)(n.p,{children:"E2E Tests the entire application from the user's perspective by simulating real use cases, ensuring all parts of the system work together as intended."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"happy path of user login process, after login was navigated to the dashboard"}),"\n",(0,i.jsx)(n.li,{children:"user in page A with a creation form filled it in correctly, submitted the data and after submitting is redirected correctly to page B and sees latest data as intended"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Slow to run and costly to write and maintain because they test the entire stack, including UI, backend, databases, and third-party services."}),"\n",(0,i.jsx)(n.li,{children:"Less frequent but crucial for verifying critical user workflows (e.g., sign-up, purchase flow)."}),"\n",(0,i.jsx)(n.li,{children:"Run against the complete, integrated system and often use browsers or automated tools to simulate user interactions."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"acceptance-testing",children:"Acceptance testing"}),"\n",(0,i.jsx)(n.p,{children:"Acceptance testing is carried out to confirm that user inputs, user flows, and any designated actions on the frontend are coded and functioning properly. Development teams perform them to make sure the final model of the application works as it is expected to by end users."}),"\n",(0,i.jsx)(n.h3,{id:"visual-regression-testing",children:"Visual regression testing"}),"\n",(0,i.jsx)(n.p,{children:"Visual regression testing is a uniquely frontend test. Other types of tests focus on code, and can therefore also be run for backend stacks. In turn, visual regression tests compare the actual/existing interface of your application with the corresponding \u2018expected\u2019 version to identify any gaps. This is achieved by comparing screenshots from a headless, server-run browser, and a machine is used to conduct image comparison between them, identifying and highlighting any differences."}),"\n",(0,i.jsx)(n.h3,{id:"accessibility-testing",children:"Accessibility testing"}),"\n",(0,i.jsxs)(n.p,{children:["Accessibility testing checks if an application or website is ",(0,i.jsx)(n.a,{href:"https://www.netguru.com/blog/accessibility-testing",children:"easily usable by every potential user"}),", including individuals with visual impairments or other additional needs. It is sometimes considered a subcategory of usability testing, and ensures that specific, unchangeable conditions don\u2019t prevent anyone from accessing any of the features or functions of the app, and that they can navigate through the interface as easily as anybody else."]}),"\n",(0,i.jsx)(n.h3,{id:"performance-testing",children:"Performance testing"}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.a,{href:"https://www.netguru.com/blog/performance-testing-tools",children:"Performance testing analyzes your application\u2019s performance"})," within specific parameters including speed, stability, scalability, interoperability and responsiveness. It is crucial to frontend testing as it helps to ensure that the product sustains its desired quality when the user load is increased, and it is fast and responsive to user requests and actions."]}),"\n",(0,i.jsx)(n.h3,{id:"integration-testing",children:"Integration testing"}),"\n",(0,i.jsx)(n.p,{children:"Integration testing in frontend tests is a software testing approach that focuses on verifying the interactions and integration points between various components or modules of a web application's user interface. It ensures that these components work together seamlessly and can involve testing how different parts of the frontend (e.g., UI elements, APIs, and data sources) interact and behave in conjunction with each other, helping to identify issues such as data flow problems, communication errors, and functional integration problems."}),"\n",(0,i.jsx)(n.h3,{id:"cross-browser-testing",children:"Cross-browser testing"}),"\n",(0,i.jsx)(n.p,{children:"Cross-browser testing is performed to confirm that an application works as expected in different web browsers. This process involves running the same set of test cases on different browsers to check that the application is compatible on each one. Because these tests are the same each time, this process can be automated."})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},3353:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/testing-pyramid-9d54d2c99341c881cd4fd72c532d0dea.png"},3665:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/types-of-frontend-testing-cbec5666e3bdb1f5c619904fe6897c43.png"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(6540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);