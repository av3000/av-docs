"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[7665],{8519:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>c,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>i});const o=JSON.parse('{"id":"frontend/react/state-management/recoil","title":"[Recoil](https://recoiljs.org/)","description":"- Recoil works and thinks like React. Add some to your app and get fast and flexible shared state.","source":"@site/docs/frontend/react/state-management/recoil.md","sourceDirName":"frontend/react/state-management","slug":"/frontend/react/state-management/recoil","permalink":"/av-docs/docs/frontend/react/state-management/recoil","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/react/state-management/recoil.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"Recoil"},"sidebar":"frontendSidebar","previous":{"title":"TanStack Query (React Query)","permalink":"/av-docs/docs/frontend/react/state-management/react-query"},"next":{"title":"Redux","permalink":"/av-docs/docs/frontend/react/state-management/redux"}}');var s=t(4848),r=t(8453);const a={sidebar_label:"Recoil"},c="Recoil",l={},i=[{value:"Why Recoil over React Context?",id:"why-recoil-over-react-context",level:2},{value:"Key Benefits",id:"key-benefits",level:2},{value:"The Context Problem - Single Context",id:"the-context-problem---single-context",level:3},{value:"Context Solution - Multiple Contexts (More Code)",id:"context-solution---multiple-contexts-more-code",level:3},{value:"Recoil Solution - Clean &amp; Atomic",id:"recoil-solution---clean--atomic",level:3},{value:"Basic Setup",id:"basic-setup",level:2},{value:"Atoms - Basic State",id:"atoms---basic-state",level:2},{value:"Atoms - Complex Objects",id:"atoms---complex-objects",level:2},{value:"Selectors - Derived State",id:"selectors---derived-state",level:2},{value:"Array State + Computed Values",id:"array-state--computed-values",level:2},{value:"Async Selectors",id:"async-selectors",level:2},{value:"Hook Patterns",id:"hook-patterns",level:2},{value:"Performance Comparison Example",id:"performance-comparison-example",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"recoil",children:(0,s.jsx)(n.a,{href:"https://recoiljs.org/",children:"Recoil"})})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Recoil works and thinks like React. Add some to your app and get fast and flexible shared state."}),"\n",(0,s.jsx)(n.li,{children:"Derived data and asynchronous queries are tamed with pure functions and efficient subscriptions."}),"\n",(0,s.jsx)(n.li,{children:"Implement persistence, routing, time-travel debugging, or undo by observing all state changes across your app, without impairing code-splitting."}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"why-recoil-over-react-context",children:"Why Recoil over React Context?"}),"\n",(0,s.jsxs)(n.p,{children:["React Context causes all consuming components to re-render when any part of the context value changes. Recoil solves this with ",(0,s.jsx)(n.strong,{children:"atomic state"})," - components only re-render when the specific atoms they subscribe to change."]}),"\n",(0,s.jsx)(n.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Granular updates"}),": Components only re-render when their specific atoms change"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Derived state"}),": Selectors automatically update when dependencies change"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Async support"}),": Built-in async state management with Suspense integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Developer tools"}),": Time-travel debugging and state inspection"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Minimal boilerplate"}),": No providers, reducers, or action creators needed"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"the-context-problem---single-context",children:"The Context Problem - Single Context"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Problem: ALL components re-render when ANY part changes\nconst AppContext = createContext({ user: null, todos: [], count: 0 });\n\nfunction App() {\n  const [state, setState] = useState({ user: null, todos: [], count: 0 });\n\n  return (\n    <AppContext.Provider value={state}>\n      <UserComponent /> {/* Re-renders when count changes! */}\n      <CountComponent /> {/* Re-renders when todos change! */}\n      <TodosComponent /> {/* Re-renders when user changes! */}\n    </AppContext.Provider>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"context-solution---multiple-contexts-more-code",children:"Context Solution - Multiple Contexts (More Code)"}),"\n",(0,s.jsxs)(n.p,{children:["You ",(0,s.jsx)(n.em,{children:"can"})," solve this with separate contexts, but it creates complexity:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Separate contexts to avoid cross re-renders\nconst CountContext = createContext();\nconst TodosContext = createContext();\nconst UserContext = createContext();\n\nfunction CountProvider({ children }) {\n  const [count, setCount] = useState(0);\n  return (\n    <CountContext.Provider value={{ count, setCount }}>\n      {children}\n    </CountContext.Provider>\n  );\n}\n\nfunction TodosProvider({ children }) {\n  const [todos, setTodos] = useState([]);\n  return (\n    <TodosContext.Provider value={{ todos, setTodos }}>\n      {children}\n    </TodosContext.Provider>\n  );\n}\n\n// Provider hell in your app\nfunction App() {\n  return (\n    <CountProvider>\n      <TodosProvider>\n        <UserProvider>\n          <CountComponent /> {/* Only re-renders when count changes */}\n          <TodosComponent /> {/* Only re-renders when todos changes */}\n        </UserProvider>\n      </TodosProvider>\n    </CountProvider>\n  );\n}\n\n// Need to manually create hooks for each context\nconst useCount = () => useContext(CountContext);\nconst useTodos = () => useContext(TodosContext);\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Problems with Multiple Contexts:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Provider nesting gets unwieldy"}),"\n",(0,s.jsx)(n.li,{children:"No built-in computed state across contexts"}),"\n",(0,s.jsx)(n.li,{children:"Manual dependency management for derived values"}),"\n",(0,s.jsx)(n.li,{children:"Lots of boilerplate code"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"recoil-solution---clean--atomic",children:"Recoil Solution - Clean & Atomic"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Simple atom definitions - no providers needed\nconst userState = atom({ key: "user", default: null });\nconst todosState = atom({ key: "todos", default: [] });\nconst countState = atom({ key: "count", default: 0 });\n\n// Built-in computed state across atoms\nconst todoStats = selector({\n  key: "todoStats",\n  get: ({ get }) => {\n    const todos = get(todosState);\n    const count = get(countState);\n    return { todosCount: todos.length, totalCount: count };\n  },\n});\n\n// Single provider for everything\nfunction App() {\n  return (\n    <RecoilRoot>\n      <CountComponent /> {/* Only re-renders when countState changes */}\n      <TodosComponent /> {/* Only re-renders when todosState changes */}\n      <StatsComponent /> {/* Re-renders when todos OR count changes */}\n    </RecoilRoot>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// App.tsx\nimport { RecoilRoot } from "recoil";\n\nexport default function App() {\n  return (\n    <RecoilRoot>\n      <YourComponents />\n    </RecoilRoot>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"atoms---basic-state",children:"Atoms - Basic State"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// atoms/counter.ts\nimport { atom } from "recoil";\n\nexport const countState = atom({\n  key: "countState", // unique ID\n  default: 0,\n});\n\n// Component usage\nimport { useRecoilState } from "recoil";\n\nfunction Counter() {\n  const [count, setCount] = useRecoilState(countState);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount((c) => c + 1)}>+</button>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"atoms---complex-objects",children:"Atoms - Complex Objects"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// atoms/user.ts\nimport { atom } from "recoil";\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\nexport const userState = atom<User | null>({\n  key: "userState",\n  default: null,\n});\n\n// Component usage\nfunction UserProfile() {\n  const [user, setUser] = useRecoilState(userState);\n\n  const login = () => {\n    setUser({ id: "1", name: "John", email: "john@example.com" });\n  };\n\n  return user ? (\n    <p>Welcome {user.name}</p>\n  ) : (\n    <button onClick={login}>Login</button>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"selectors---derived-state",children:"Selectors - Derived State"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// atoms/selectors.ts\nimport { selector } from "recoil";\nimport { countState, userState } from "./atoms";\n\n// Simple computation\nexport const doubledCount = selector({\n  key: "doubledCount",\n  get: ({ get }) => {\n    const count = get(countState);\n    return count * 2;\n  },\n});\n\n// Multi-atom computation\nexport const userDisplayName = selector({\n  key: "userDisplayName",\n  get: ({ get }) => {\n    const user = get(userState);\n    return user ? `${user.name} (${user.email})` : "Guest";\n  },\n});\n\n// Component usage - read-only\nfunction Display() {\n  const doubled = useRecoilValue(doubledCount);\n  const displayName = useRecoilValue(userDisplayName);\n\n  return (\n    <p>\n      {displayName} - Count x2: {doubled}\n    </p>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"array-state--computed-values",children:"Array State + Computed Values"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// atoms/todos.ts\nimport { atom, selector } from "recoil";\n\ninterface Todo {\n  id: number;\n  text: string;\n  completed: boolean;\n}\n\nexport const todosState = atom<Todo[]>({\n  key: "todosState",\n  default: [],\n});\n\nexport const todoStats = selector({\n  key: "todoStats",\n  get: ({ get }) => {\n    const todos = get(todosState);\n    return {\n      total: todos.length,\n      completed: todos.filter((t) => t.completed).length,\n      remaining: todos.filter((t) => !t.completed).length,\n    };\n  },\n});\n\n// Component usage\nfunction TodoList() {\n  const [todos, setTodos] = useRecoilState(todosState);\n  const stats = useRecoilValue(todoStats);\n\n  const addTodo = (text: string) => {\n    setTodos((prev) => [...prev, { id: Date.now(), text, completed: false }]);\n  };\n\n  const toggleTodo = (id: number) => {\n    setTodos((prev) =>\n      prev.map((todo) =>\n        todo.id === id ? { ...todo, completed: !todo.completed } : todo\n      )\n    );\n  };\n\n  return (\n    <div>\n      <p>\n        Stats: {stats.completed}/{stats.total} completed\n      </p>\n      {todos.map((todo) => (\n        <div key={todo.id}>\n          <input\n            type="checkbox"\n            checked={todo.completed}\n            onChange={() => toggleTodo(todo.id)}\n          />\n          {todo.text}\n        </div>\n      ))}\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"async-selectors",children:"Async Selectors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// atoms/async.ts\nimport { selector } from "recoil";\nimport { userState } from "./user";\n\nexport const userProfileData = selector({\n  key: "userProfileData",\n  get: async ({ get }) => {\n    const user = get(userState);\n    if (!user) return null;\n\n    const response = await fetch(`/api/users/${user.id}`);\n    return response.json();\n  },\n});\n\n// Component usage - requires Suspense\nfunction AsyncUserData() {\n  const profileData = useRecoilValue(userProfileData);\n\n  return profileData ? (\n    <div>Profile: {JSON.stringify(profileData)}</div>\n  ) : (\n    <div>No user data</div>\n  );\n}\n\n// Wrap with Suspense\nfunction App() {\n  return (\n    <RecoilRoot>\n      <Suspense fallback={<div>Loading...</div>}>\n        <AsyncUserData />\n      </Suspense>\n    </RecoilRoot>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"hook-patterns",children:"Hook Patterns"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:'// Different ways to interact with atoms\n\nimport { useRecoilState, useRecoilValue, useSetRecoilState } from "recoil";\n\nfunction HookExamples() {\n  // Read + Write\n  const [count, setCount] = useRecoilState(countState);\n\n  // Read only (better performance if you don\'t need setter)\n  const doubled = useRecoilValue(doubledCount);\n\n  // Write only\n  const setUser = useSetRecoilState(userState);\n\n  return (\n    <div>\n      <p>\n        Count: {count}, Doubled: {doubled}\n      </p>\n      <button onClick={() => setCount((c) => c + 1)}>Increment</button>\n      <button\n        onClick={() =>\n          setUser({ id: "1", name: "Jane", email: "jane@example.com" })\n        }\n      >\n        Set User\n      </button>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"performance-comparison-example",children:"Performance Comparison Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-tsx",children:"// Context approach - ALL components re-render\nconst AppContext = createContext({\n  user: null,\n  count: 0,\n  todos: [],\n});\n\nfunction ContextApp() {\n  const [state, setState] = useState({ user: null, count: 0, todos: [] });\n\n  return (\n    <AppContext.Provider value={state}>\n      <UserComponent /> {/* Re-renders when count changes */}\n      <CountComponent /> {/* Re-renders when user changes */}\n      <TodosComponent /> {/* Re-renders when count changes */}\n    </AppContext.Provider>\n  );\n}\n\n// Recoil approach - ONLY relevant components re-render\nfunction RecoilApp() {\n  return (\n    <RecoilRoot>\n      <UserComponent /> {/* Only re-renders when userState changes */}\n      <CountComponent /> {/* Only re-renders when countState changes */}\n      <TodosComponent /> {/* Only re-renders when todosState changes */}\n    </RecoilRoot>\n  );\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>c});var o=t(6540);const s={},r=o.createContext(s);function a(e){const n=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);