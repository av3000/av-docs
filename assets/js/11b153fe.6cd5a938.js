"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[9785],{9578:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"frontend/react/state-management/redux","title":"Redux","description":"Why Redux over React State?","source":"@site/docs/frontend/react/state-management/redux.md","sourceDirName":"frontend/react/state-management","slug":"/frontend/react/state-management/redux","permalink":"/av-docs/docs/frontend/react/state-management/redux","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/react/state-management/redux.md","tags":[],"version":"current","frontMatter":{},"sidebar":"frontendSidebar","previous":{"title":"Recoil","permalink":"/av-docs/docs/frontend/react/state-management/recoil"},"next":{"title":"XState","permalink":"/av-docs/docs/frontend/react/state-management/xstate"}}');var s=n(4848),r=n(8453);const a={},i="Redux",d={},c=[{value:"Why Redux over React State?",id:"why-redux-over-react-state",level:2},{value:"Key Benefits",id:"key-benefits",level:2},{value:"The React State Problem - Prop Drilling &amp; State Sharing",id:"the-react-state-problem---prop-drilling--state-sharing",level:3},{value:"Context &quot;Solution&quot; - Still Has Issues",id:"context-solution---still-has-issues",level:3},{value:"Redux Solution - Predictable State Management",id:"redux-solution---predictable-state-management",level:3},{value:"Basic Setup (Redux Toolkit)",id:"basic-setup-redux-toolkit",level:2},{value:"Simple Slice (Redux Toolkit)",id:"simple-slice-redux-toolkit",level:2},{value:"Complex State - Todos with Normalized Data",id:"complex-state---todos-with-normalized-data",level:2},{value:"Async Operations with createAsyncThunk",id:"async-operations-with-createasyncthunk",level:2},{value:"RTK Query for Data Fetching",id:"rtk-query-for-data-fetching",level:2},{value:"Typed Hooks for Better DX",id:"typed-hooks-for-better-dx",level:2},{value:"Middleware Example",id:"middleware-example",level:2}];function l(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(t.header,{children:(0,s.jsx)(t.h1,{id:"redux",children:"Redux"})}),"\n",(0,s.jsx)(t.h2,{id:"why-redux-over-react-state",children:"Why Redux over React State?"}),"\n",(0,s.jsxs)(t.p,{children:[(0,s.jsx)(t.a,{href:"https://redux-toolkit.js.org/",children:(0,s.jsx)(t.strong,{children:"Redux Toolkit"})})," - Official Redux toolset"]}),"\n",(0,s.jsx)(t.p,{children:"React's built-in state works well for component-level data, but becomes problematic for complex apps with shared state, deep prop drilling, and complex state logic. Redux provides predictable state management with time-travel debugging and powerful dev tools."}),"\n",(0,s.jsx)(t.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(t.ul,{children:["\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Predictable state updates"}),": Actions describe what happened, reducers specify how state changes"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Time-travel debugging"}),": Redux DevTools let you replay actions and inspect state changes"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Centralized state"}),": No prop drilling, any component can access any state"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Powerful dev tools"}),": Best-in-class debugging and state inspection"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Middleware ecosystem"}),": Logging, persistence, API integration, etc."]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Performance optimizations"}),": Components only re-render when their selected state changes"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Testable logic"}),": Pure reducer functions are easy to test"]}),"\n",(0,s.jsxs)(t.li,{children:[(0,s.jsx)(t.strong,{children:"Hot reloading"}),": State persists during development"]}),"\n"]}),"\n",(0,s.jsx)(t.h3,{id:"the-react-state-problem---prop-drilling--state-sharing",children:"The React State Problem - Prop Drilling & State Sharing"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'// Problem: Deep prop drilling and scattered state\nfunction App() {\n  const [user, setUser] = useState(null);\n  const [cart, setCart] = useState([]);\n  const [theme, setTheme] = useState("light");\n  const [notifications, setNotifications] = useState([]);\n\n  return (\n    <div>\n      <Header\n        user={user}\n        cart={cart}\n        theme={theme}\n        setTheme={setTheme}\n        notifications={notifications}\n        setNotifications={setNotifications}\n      />\n      <MainContent user={user} cart={cart} setCart={setCart} theme={theme} />\n      <Sidebar user={user} setUser={setUser} notifications={notifications} />\n    </div>\n  );\n}\n\n// Header needs to pass props down further\nfunction Header({\n  user,\n  cart,\n  theme,\n  setTheme,\n  notifications,\n  setNotifications,\n}) {\n  return (\n    <header>\n      <UserMenu user={user} />\n      <CartIcon cart={cart} />\n      <ThemeToggle theme={theme} setTheme={setTheme} />\n      <NotificationBell\n        notifications={notifications}\n        setNotifications={setNotifications}\n      />\n    </header>\n  );\n}\n\n// Components 5 levels deep still need these props!\nfunction NotificationBell({ notifications, setNotifications }) {\n  // Finally using the props after passing through 5 components\n  const clearNotification = (id) => {\n    setNotifications((prev) => prev.filter((n) => n.id !== id));\n  };\n}\n'})}),"\n",(0,s.jsx)(t.h3,{id:"context-solution---still-has-issues",children:'Context "Solution" - Still Has Issues'}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'// Context helps with prop drilling but creates other problems\nconst AppContext = createContext();\n\nfunction AppProvider({ children }) {\n  const [state, setState] = useState({\n    user: null,\n    cart: [],\n    theme: "light",\n    notifications: [],\n  });\n\n  // Problem: All logic in one place becomes messy\n  const updateCart = (item) => {\n    setState((prev) => ({\n      ...prev,\n      cart: [...prev.cart, item], // Easy to mutate by mistake\n    }));\n  };\n\n  const clearNotification = (id) => {\n    setState((prev) => ({\n      ...prev,\n      notifications: prev.notifications.filter((n) => n.id !== id),\n    }));\n  };\n\n  // Value changes on every render - performance issues\n  const value = {\n    ...state,\n    updateCart,\n    clearNotification,\n  };\n\n  return <AppContext.Provider value={value}>{children}</AppContext.Provider>;\n}\n\n// Problems:\n// 1. All components re-render when ANY state changes\n// 2. Complex state logic mixed with component logic\n// 3. No time-travel debugging\n// 4. Hard to test state logic in isolation\n// 5. No dev tools for state inspection\n'})}),"\n",(0,s.jsx)(t.h3,{id:"redux-solution---predictable-state-management",children:"Redux Solution - Predictable State Management"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:"// Solution: Centralized, predictable state with powerful tools\nconst store = configureStore({\n  reducer: {\n    user: userSlice.reducer,\n    cart: cartSlice.reducer,\n    theme: themeSlice.reducer,\n    notifications: notificationsSlice.reducer,\n  },\n});\n\n// Components only re-render when their specific state changes\nfunction NotificationBell() {\n  const notifications = useSelector((state) => state.notifications);\n  const dispatch = useDispatch();\n\n  const clearNotification = (id) => {\n    dispatch(removeNotification(id));\n  };\n\n  // Component only re-renders when notifications change\n  // State logic is separate and testable\n  // Full dev tools support with time-travel debugging\n}\n"})}),"\n",(0,s.jsx)(t.h2,{id:"basic-setup-redux-toolkit",children:"Basic Setup (Redux Toolkit)"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'// Install: npm install @reduxjs/toolkit react-redux\n\n// store/index.ts\nimport { configureStore } from "@reduxjs/toolkit";\nimport counterSlice from "./counterSlice";\n\nexport const store = configureStore({\n  reducer: {\n    counter: counterSlice,\n  },\n});\n\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n\n// App.tsx\nimport { Provider } from "react-redux";\nimport { store } from "./store";\n\nfunction App() {\n  return (\n    <Provider store={store}>\n      <YourComponents />\n    </Provider>\n  );\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"simple-slice-redux-toolkit",children:"Simple Slice (Redux Toolkit)"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'// store/counterSlice.ts\nimport { createSlice, PayloadAction } from "@reduxjs/toolkit";\n\ninterface CounterState {\n  value: number;\n  step: number;\n}\n\nconst initialState: CounterState = {\n  value: 0,\n  step: 1,\n};\n\nexport const counterSlice = createSlice({\n  name: "counter",\n  initialState,\n  reducers: {\n    increment: (state) => {\n      // RTK uses Immer - direct mutations are safe\n      state.value += state.step;\n    },\n    decrement: (state) => {\n      state.value -= state.step;\n    },\n    incrementByAmount: (state, action: PayloadAction<number>) => {\n      state.value += action.payload;\n    },\n    setStep: (state, action: PayloadAction<number>) => {\n      state.step = action.payload;\n    },\n    reset: (state) => {\n      state.value = 0;\n    },\n  },\n});\n\nexport const { increment, decrement, incrementByAmount, setStep, reset } =\n  counterSlice.actions;\nexport default counterSlice.reducer;\n\n// Component usage\nimport { useSelector, useDispatch } from "react-redux";\nimport { increment, decrement, setStep, reset } from "./store/counterSlice";\n\nfunction Counter() {\n  const { value, step } = useSelector((state: RootState) => state.counter);\n  const dispatch = useDispatch();\n\n  return (\n    <div>\n      <p>\n        Count: {value} (Step: {step})\n      </p>\n      <button onClick={() => dispatch(increment())}>+</button>\n      <button onClick={() => dispatch(decrement())}>-</button>\n      <button onClick={() => dispatch(setStep(5))}>Set Step to 5</button>\n      <button onClick={() => dispatch(reset())}>Reset</button>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"complex-state---todos-with-normalized-data",children:"Complex State - Todos with Normalized Data"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'// store/todosSlice.ts\nimport {\n  createSlice,\n  createEntityAdapter,\n  PayloadAction,\n} from "@reduxjs/toolkit";\n\ninterface Todo {\n  id: string;\n  text: string;\n  completed: boolean;\n  userId: string;\n  createdAt: string;\n}\n\n// Entity adapter for normalized state\nconst todosAdapter = createEntityAdapter<Todo>({\n  sortComparer: (a, b) => b.createdAt.localeCompare(a.createdAt),\n});\n\ninterface TodosState {\n  filter: "all" | "active" | "completed";\n}\n\nconst todosSlice = createSlice({\n  name: "todos",\n  initialState: todosAdapter.getInitialState<TodosState>({\n    filter: "all",\n  }),\n  reducers: {\n    addTodo: (state, action: PayloadAction<Omit<Todo, "id">>) => {\n      const todo: Todo = {\n        ...action.payload,\n        id: Date.now().toString(),\n      };\n      todosAdapter.addOne(state, todo);\n    },\n    removeTodo: (state, action: PayloadAction<string>) => {\n      todosAdapter.removeOne(state, action.payload);\n    },\n    toggleTodo: (state, action: PayloadAction<string>) => {\n      const todo = state.entities[action.payload];\n      if (todo) {\n        todo.completed = !todo.completed;\n      }\n    },\n    updateTodo: (\n      state,\n      action: PayloadAction<{ id: string; text: string }>\n    ) => {\n      const { id, text } = action.payload;\n      const todo = state.entities[id];\n      if (todo) {\n        todo.text = text;\n      }\n    },\n    setFilter: (state, action: PayloadAction<TodosState["filter"]>) => {\n      state.filter = action.payload;\n    },\n    clearCompleted: (state) => {\n      const completedIds = Object.values(state.entities)\n        .filter((todo) => todo?.completed)\n        .map((todo) => todo!.id);\n      todosAdapter.removeMany(state, completedIds);\n    },\n  },\n});\n\n// Selectors\nexport const {\n  selectAll: selectAllTodos,\n  selectById: selectTodoById,\n  selectIds: selectTodoIds,\n} = todosAdapter.getSelectors((state: RootState) => state.todos);\n\n// Custom selectors\nexport const selectFilteredTodos = (state: RootState) => {\n  const todos = selectAllTodos(state);\n  const filter = state.todos.filter;\n\n  switch (filter) {\n    case "active":\n      return todos.filter((todo) => !todo.completed);\n    case "completed":\n      return todos.filter((todo) => todo.completed);\n    default:\n      return todos;\n  }\n};\n\nexport const selectTodoStats = (state: RootState) => {\n  const todos = selectAllTodos(state);\n  return {\n    total: todos.length,\n    completed: todos.filter((t) => t.completed).length,\n    remaining: todos.filter((t) => !t.completed).length,\n  };\n};\n\nexport const {\n  addTodo,\n  removeTodo,\n  toggleTodo,\n  updateTodo,\n  setFilter,\n  clearCompleted,\n} = todosSlice.actions;\nexport default todosSlice.reducer;\n\n// Component usage\nfunction TodoList() {\n  const todos = useSelector(selectFilteredTodos);\n  const stats = useSelector(selectTodoStats);\n  const filter = useSelector((state: RootState) => state.todos.filter);\n  const dispatch = useDispatch();\n\n  const handleAddTodo = (text: string) => {\n    dispatch(\n      addTodo({\n        text,\n        completed: false,\n        userId: "current-user",\n        createdAt: new Date().toISOString(),\n      })\n    );\n  };\n\n  return (\n    <div>\n      <div>\n        <p>\n          Stats: {stats.completed}/{stats.total} completed\n        </p>\n\n        <div>\n          {(["all", "active", "completed"] as const).map((filterType) => (\n            <button\n              key={filterType}\n              onClick={() => dispatch(setFilter(filterType))}\n              disabled={filter === filterType}\n            >\n              {filterType}\n            </button>\n          ))}\n        </div>\n      </div>\n\n      {todos.map((todo) => (\n        <div key={todo.id}>\n          <input\n            type="checkbox"\n            checked={todo.completed}\n            onChange={() => dispatch(toggleTodo(todo.id))}\n          />\n          <span>{todo.text}</span>\n          <button onClick={() => dispatch(removeTodo(todo.id))}>\xd7</button>\n        </div>\n      ))}\n\n      <button onClick={() => dispatch(clearCompleted())}>\n        Clear Completed\n      </button>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"async-operations-with-createasyncthunk",children:"Async Operations with createAsyncThunk"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'// store/userSlice.ts\nimport { createSlice, createAsyncThunk } from "@reduxjs/toolkit";\n\ninterface User {\n  id: string;\n  name: string;\n  email: string;\n}\n\ninterface UserState {\n  current: User | null;\n  loading: boolean;\n  error: string | null;\n}\n\n// Async thunk for API calls\nexport const fetchUser = createAsyncThunk(\n  "user/fetchUser",\n  async (userId: string, { rejectWithValue }) => {\n    try {\n      const response = await fetch(`/api/users/${userId}`);\n      if (!response.ok) {\n        throw new Error("Failed to fetch user");\n      }\n      return await response.json();\n    } catch (error) {\n      return rejectWithValue(error.message);\n    }\n  }\n);\n\nexport const updateUser = createAsyncThunk(\n  "user/updateUser",\n  async (userData: Partial<User> & { id: string }) => {\n    const response = await fetch(`/api/users/${userData.id}`, {\n      method: "PUT",\n      headers: { "Content-Type": "application/json" },\n      body: JSON.stringify(userData),\n    });\n    return await response.json();\n  }\n);\n\nconst userSlice = createSlice({\n  name: "user",\n  initialState: {\n    current: null,\n    loading: false,\n    error: null,\n  } as UserState,\n  reducers: {\n    clearError: (state) => {\n      state.error = null;\n    },\n    logout: (state) => {\n      state.current = null;\n      state.error = null;\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      // Fetch user\n      .addCase(fetchUser.pending, (state) => {\n        state.loading = true;\n        state.error = null;\n      })\n      .addCase(fetchUser.fulfilled, (state, action) => {\n        state.loading = false;\n        state.current = action.payload;\n      })\n      .addCase(fetchUser.rejected, (state, action) => {\n        state.loading = false;\n        state.error = action.payload as string;\n      })\n      // Update user\n      .addCase(updateUser.fulfilled, (state, action) => {\n        state.current = action.payload;\n      });\n  },\n});\n\nexport const { clearError, logout } = userSlice.actions;\nexport default userSlice.reducer;\n\n// Component usage\nfunction UserProfile() {\n  const {\n    current: user,\n    loading,\n    error,\n  } = useSelector((state: RootState) => state.user);\n  const dispatch = useDispatch();\n\n  useEffect(() => {\n    dispatch(fetchUser("current-user-id"));\n  }, [dispatch]);\n\n  const handleUpdateProfile = (updates: Partial<User>) => {\n    if (user) {\n      dispatch(updateUser({ ...updates, id: user.id }));\n    }\n  };\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error}</div>;\n  if (!user) return <div>No user found</div>;\n\n  return (\n    <div>\n      <h2>{user.name}</h2>\n      <p>{user.email}</p>\n      <button onClick={() => handleUpdateProfile({ name: "Updated Name" })}>\n        Update Name\n      </button>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"rtk-query-for-data-fetching",children:"RTK Query for Data Fetching"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'// store/api.ts\nimport { createApi, fetchBaseQuery } from "@reduxjs/toolkit/query/react";\n\ninterface Post {\n  id: number;\n  title: string;\n  body: string;\n  userId: number;\n}\n\nexport const postsApi = createApi({\n  reducerPath: "postsApi",\n  baseQuery: fetchBaseQuery({\n    baseUrl: "/api/",\n  }),\n  tagTypes: ["Post"],\n  endpoints: (builder) => ({\n    getPosts: builder.query<Post[], void>({\n      query: () => "posts",\n      providesTags: ["Post"],\n    }),\n    getPost: builder.query<Post, number>({\n      query: (id) => `posts/${id}`,\n      providesTags: (result, error, id) => [{ type: "Post", id }],\n    }),\n    createPost: builder.mutation<Post, Omit<Post, "id">>({\n      query: (newPost) => ({\n        url: "posts",\n        method: "POST",\n        body: newPost,\n      }),\n      invalidatesTags: ["Post"],\n    }),\n    updatePost: builder.mutation<Post, Partial<Post> & { id: number }>({\n      query: ({ id, ...patch }) => ({\n        url: `posts/${id}`,\n        method: "PATCH",\n        body: patch,\n      }),\n      invalidatesTags: (result, error, { id }) => [{ type: "Post", id }],\n    }),\n    deletePost: builder.mutation<void, number>({\n      query: (id) => ({\n        url: `posts/${id}`,\n        method: "DELETE",\n      }),\n      invalidatesTags: ["Post"],\n    }),\n  }),\n});\n\nexport const {\n  useGetPostsQuery,\n  useGetPostQuery,\n  useCreatePostMutation,\n  useUpdatePostMutation,\n  useDeletePostMutation,\n} = postsApi;\n\n// Add to store\nexport const store = configureStore({\n  reducer: {\n    counter: counterSlice,\n    todos: todosSlice,\n    user: userSlice,\n    [postsApi.reducerPath]: postsApi.reducer,\n  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().concat(postsApi.middleware),\n});\n\n// Component usage\nfunction PostsList() {\n  const { data: posts, error, isLoading, refetch } = useGetPostsQuery();\n  const [createPost] = useCreatePostMutation();\n  const [deletePost] = useDeletePostMutation();\n\n  const handleCreatePost = async () => {\n    try {\n      await createPost({\n        title: "New Post",\n        body: "Post content",\n        userId: 1,\n      }).unwrap();\n    } catch (error) {\n      console.error("Failed to create post:", error);\n    }\n  };\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error loading posts</div>;\n\n  return (\n    <div>\n      <button onClick={handleCreatePost}>Create Post</button>\n      <button onClick={refetch}>Refresh</button>\n\n      {posts?.map((post) => (\n        <div key={post.id}>\n          <h3>{post.title}</h3>\n          <p>{post.body}</p>\n          <button onClick={() => deletePost(post.id)}>Delete</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"typed-hooks-for-better-dx",children:"Typed Hooks for Better DX"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'// store/hooks.ts\nimport { useDispatch, useSelector, TypedUseSelectorHook } from "react-redux";\nimport type { RootState, AppDispatch } from "./index";\n\n// Typed versions of hooks\nexport const useAppDispatch = () => useDispatch<AppDispatch>();\nexport const useAppSelector: TypedUseSelectorHook<RootState> = useSelector;\n\n// Usage in components\nfunction TypedComponent() {\n  const count = useAppSelector((state) => state.counter.value); // Fully typed\n  const dispatch = useAppDispatch(); // Typed dispatch\n\n  return <div>{count}</div>;\n}\n'})}),"\n",(0,s.jsx)(t.h2,{id:"middleware-example",children:"Middleware Example"}),"\n",(0,s.jsx)(t.pre,{children:(0,s.jsx)(t.code,{className:"language-tsx",children:'// store/middleware.ts\nimport { createListenerMiddleware, isAnyOf } from "@reduxjs/toolkit";\nimport { increment, decrement } from "./counterSlice";\n\n// Listener middleware for side effects\nexport const listenerMiddleware = createListenerMiddleware();\n\n// Log all counter actions\nlistenerMiddleware.startListening({\n  matcher: isAnyOf(increment, decrement),\n  effect: (action, listenerApi) => {\n    const state = listenerApi.getState() as RootState;\n    console.log("Counter updated:", state.counter.value);\n\n    // Save to localStorage\n    localStorage.setItem("counter", JSON.stringify(state.counter));\n  },\n});\n\n// Add to store\nexport const store = configureStore({\n  reducer: {\n    /* your reducers */\n  },\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware().prepend(listenerMiddleware.middleware),\n});\n'})})]})}function u(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,s.jsx)(t,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>i});var o=n(6540);const s={},r=o.createContext(s);function a(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);