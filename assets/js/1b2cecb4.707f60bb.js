"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[7649],{3181:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"system-design/software-development-principles/index","title":"Software development principles","description":"https://thetshaped.dev/p/3-software-development-principles","source":"@site/docs/system-design/software-development-principles/index.md","sourceDirName":"system-design/software-development-principles","slug":"/system-design/software-development-principles/","permalink":"/av-docs/docs/system-design/software-development-principles/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/system-design/software-development-principles/index.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_label":"Intro","sidebar_position":1}}');var s=t(4848),a=t(8453);const r={sidebar_label:"Intro",sidebar_position:1},o="Software development principles",l={},c=[{value:"YAGNI - you are not gonna need it",id:"yagni---you-are-not-gonna-need-it",level:2},{value:"KISS - Keep it simple, stupid",id:"kiss---keep-it-simple-stupid",level:2},{value:"DRY - Do not repeat yourself",id:"dry---do-not-repeat-yourself",level:2},{value:"SOLID",id:"solid",level:2},{value:"Single-Responsibility Principle",id:"single-responsibility-principle",level:3},{value:"Open-Closed Principle",id:"open-closed-principle",level:3},{value:"Interface Segregation Principle",id:"interface-segregation-principle",level:3},{value:"Dependency Inversion Principle",id:"dependency-inversion-principle",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"software-development-principles",children:"Software development principles"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://thetshaped.dev/p/3-software-development-principles",children:"https://thetshaped.dev/p/3-software-development-principles"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"/av-docs/docs/system-design/software-development-principles/oop",children:"Object-Oriented programming"})}),"\n",(0,s.jsx)(n.h1,{id:"list",children:"List"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#yagni---you-are-not-gonna-need-it",children:"YAGNI"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#kiss---keep-it-simple-stupid",children:"KISS"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#dry---do-not-repeat-yourself",children:"DRY"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#solid",children:"SOLID"})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"yagni---you-are-not-gonna-need-it",children:"YAGNI - you are not gonna need it"}),"\n",(0,s.jsx)(n.p,{children:"Don\u2019t add features or functionality to our software that we currently don\u2019t need.\nHelps to avoid clutter and maintenance burden."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// BAD: Adding future functionality that isn\'t required yet.\nclass CarplateService {\n  // Current requirement: Get carplate by ID\n  getCarplate(id: string): string {\n    return `Carplate ${id}`;\n  }\n\n  // Added for "potential future use" but not needed now\n  generateRandomCarplate(): string {\n    return `Random-1234`; // This is unnecessary for now.\n  }\n}\n\n// GOOD: Focus only on the current need.\nclass CarplateServiceSimplified {\n  getCarplate(id: string): string {\n    return `Carplate ${id}`;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"kiss---keep-it-simple-stupid",children:"KISS - Keep it simple, stupid"}),"\n",(0,s.jsx)(n.p,{children:"Don\u2019t add unnecessary complexity to our software."}),"\n",(0,s.jsx)(n.p,{children:"The KISS rule means keeping our code easy to read and understand. Instead of making things complicated and \u201csmart\u201d, try to write code that\u2019s straight to the point. This makes it easier for you and others to keep track of what\u2019s going on and fix things when they go wrong."}),"\n",(0,s.jsx)(n.p,{children:'Instead of being too "smart" in your code, think about your colleagues and future teammates. Maybe it\'s better to write 2-3 lines more, but guarantee that your future teammates will understand it'}),"\n",(0,s.jsxs)(n.p,{children:["It\u2019s important to note that sometimes adding more layers of ",(0,s.jsx)(n.strong,{children:"abstraction"})," in our codebase may seem to conflict with the KISS principle because we add layers of complexity. However, when done carefully, abstraction can simplify the overall design by hiding complex logic behind simpler interfaces or functions. In the end, it makes our code easier to read, understand, and maintain which is our end goal."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// BAD: Over-engineering a calculation with unnecessary abstraction.\nclass TaxCalculator {\n  calculateTax(income: number): number {\n    // Over-complicated logic\n    return income * this.getTaxRate() * 0.9 + 0.01;\n  }\n\n  private getTaxRate(): number {\n    return Math.random(); // Arbitrary complexity\n  }\n}\n\n// GOOD: Straightforward and readable implementation.\nclass SimpleTaxCalculator {\n  calculateTax(income: number): number {\n    const taxRate = 0.15; // Fixed and understandable\n    return income * taxRate;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dry---do-not-repeat-yourself",children:"DRY - Do not repeat yourself"}),"\n",(0,s.jsx)(n.p,{children:"Don\u2019t duplicate code or data in our software."}),"\n",(0,s.jsx)(n.p,{children:"The DRY rule is about not writing the same code over and over again. If you find yourself doing the same thing in several places, find a way to do it just once. This makes your code cleaner and easier to change later."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// BAD: Duplicating the same validation logic.\nfunction validateCarplate(carplate: string): boolean {\n  return carplate.length === 7 && /^[A-Z0-9]+$/.test(carplate);\n}\n\nfunction validateLicense(license: string): boolean {\n  return license.length === 7 && /^[A-Z0-9]+$/.test(license);\n}\n\n// GOOD: Extracting shared validation logic.\nfunction validateInput(input: string): boolean {\n  return input.length === 7 && /^[A-Z0-9]+$/.test(input);\n}\n\nfunction validateCarplate(carplate: string): boolean {\n  return validateInput(carplate);\n}\n\nfunction validateLicense(license: string): boolean {\n  return validateInput(license);\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"solid",children:"SOLID"}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.a,{href:"https://www.digitalocean.com/community/conceptual-articles/s-o-l-i-d-the-first-five-principles-of-object-oriented-design",children:"SOLID principles"})}),"\n",(0,s.jsx)(n.h3,{id:"single-responsibility-principle",children:"Single-Responsibility Principle"}),"\n",(0,s.jsx)(n.p,{children:"A class should have one and only one reason to change, meaning that a class should have only one job."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// BAD: A class handling multiple responsibilities.\nclass CarplateManager {\n  saveCarplateToDb(carplate: string): void {\n    console.log(`Saving ${carplate} to DB`);\n  }\n\n  logCarplate(carplate: string): void {\n    console.log(`Logging carplate: ${carplate}`);\n  }\n}\n\n// GOOD: Splitting responsibilities into separate classes.\nclass CarplateLogger {\n  log(carplate: string): void {\n    console.log(`Logging carplate: ${carplate}`);\n  }\n}\n\nclass CarplateRepository {\n  save(carplate: string): void {\n    console.log(`Saving ${carplate} to DB`);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"open-closed-principle",children:"Open-Closed Principle"}),"\n",(0,s.jsx)(n.p,{children:"Objects or entities should be open for extension but closed for modification."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// BAD: Modifying the class to add new behavior.\nclass NotificationService {\n  sendNotification(type: string, message: string): void {\n    if (type === "email") {\n      console.log(`Sending email: ${message}`);\n    } else if (type === "sms") {\n      console.log(`Sending SMS: ${message}`);\n    }\n  }\n}\n\n// GOOD: Extending behavior via polymorphism.\ninterface Notifier {\n  send(message: string): void;\n}\n\nclass EmailNotifier implements Notifier {\n  send(message: string): void {\n    console.log(`Sending email: ${message}`);\n  }\n}\n\nclass SMSNotifier implements Notifier {\n  send(message: string): void {\n    console.log(`Sending SMS: ${message}`);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"interface-segregation-principle",children:"Interface Segregation Principle"}),"\n",(0,s.jsx)(n.p,{children:"A client should never be forced to implement an interface that it doesn\u2019t use, or clients shouldn\u2019t be forced to depend on methods they do not use."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'// BAD: Single interface with unused methods.\ninterface CarService {\n  washCar(): void;\n  paintCar(color: string): void;\n}\n\nclass CarWash implements CarService {\n  washCar(): void {\n    console.log("Washing car...");\n  }\n\n  paintCar(color: string): void {\n    throw new Error("Not implemented"); // Violates ISP\n  }\n}\n\n// GOOD: Separate smaller interfaces.\ninterface CarWashService {\n  washCar(): void;\n}\n\ninterface CarPaintService {\n  paintCar(color: string): void;\n}\n\nclass CarWashOnly implements CarWashService {\n  washCar(): void {\n    console.log("Washing car...");\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"dependency-inversion-principle",children:"Dependency Inversion Principle"}),"\n",(0,s.jsx)(n.p,{children:"Entities must depend on abstractions, not on concretions. It states that the high-level module must not depend on the low-level module, but they should depend on abstractions."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// BAD: High-level module depends on low-level implementation.\nclass CarplateController {\n  service = new CarplateService(); // Tightly coupled\n\n  getCarplates() {\n    return this.service.fetchAll();\n  }\n}\n\n// GOOD: High-level module depends on abstraction.\ninterface CarplateServiceInterface {\n  fetchAll(): string[];\n}\n\nclass CarplateService implements CarplateServiceInterface {\n  fetchAll(): string[] {\n    return ['ABC123', 'CBA321'];\n  }\n}\n\nclass CarplateController {\n  constructor(private service: CarplateServiceInterface) {}\n\n  getCarplates() {\n    return this.service.fetchAll();\n  }\n}\n"})})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>r,x:()=>o});var i=t(6540);const s={},a=i.createContext(s);function r(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);