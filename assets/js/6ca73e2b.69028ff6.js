"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[4382],{4123:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"frontend/testing/index","title":"Frontend Testing","description":"There are 3 main categories of testing:","source":"@site/docs/frontend/testing/index.md","sourceDirName":"frontend/testing","slug":"/frontend/testing/","permalink":"/av-docs/docs/frontend/testing/","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/testing/index.md","tags":[],"version":"current","frontMatter":{},"sidebar":"frontendSidebar","previous":{"title":"Intro","permalink":"/av-docs/docs/frontend/"}}');var i=t(4848),o=t(8453);const a={},r="Frontend Testing",c={},l=[{value:"Unit Test",id:"unit-test",level:2},{value:"Component Test",id:"component-test",level:2},{value:"4 Reasons Component Testing is Hard ( In Angular)",id:"4-reasons-component-testing-is-hard--in-angular",level:3},{value:"End-to-End(E2E) Test",id:"end-to-ende2e-test",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",ol:"ol",p:"p",ul:"ul",...(0,o.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"frontend-testing",children:"Frontend Testing"})}),"\n",(0,i.jsx)(n.p,{children:"There are 3 main categories of testing:"}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"testing-pyramid",src:t(3353).A+"",width:"449",height:"430"})}),"\n",(0,i.jsx)(n.p,{children:"Structure of software tests to ensure reliable, efficient, and scalable testing practices.\nIt provides a clear guideline on how to distribute different types of tests in a project to achieve high test coverage with minimal maintenance costs."}),"\n",(0,i.jsx)(n.h2,{id:"unit-test",children:"Unit Test"}),"\n",(0,i.jsx)(n.p,{children:"Unit test is something when we instantiate the class on our own inside our test we're calling new class that we pass on the mocked version of dependencies and we test the class itself. No DOM interaction and no testbed(Angular), just basic individual units or functions in isolation, focusing on a small part of the code."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"helper function to transform value to display-friendly value"}),"\n",(0,i.jsx)(n.li,{children:"validator function to check if email is valid"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fast to write and execute."}),"\n",(0,i.jsx)(n.li,{children:"High in volume, covering the majority of the codebase."}),"\n",(0,i.jsx)(n.li,{children:"Cheap to maintain since they only focus on a single unit of functionality."}),"\n",(0,i.jsx)(n.li,{children:"Ensure correctness of functions, methods, or classes in isolation from external dependencies."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"component-test",children:"Component Test"}),"\n",(0,i.jsx)(n.p,{children:"Component test has a testbed(Angular), the DOM interaction, focuses on testing individual components (often UI components or logical groupings of code) and their interactions with other components or dependencies ensuring component behaves as expected when iteracting with surounded components or services."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"service layer interaction with a database"}),"\n",(0,i.jsx)(n.li,{children:"component UI element event is triggered after button clicked and event was dispatched"}),"\n",(0,i.jsx)(n.li,{children:"component loading state was dispatched and displayed correctly after loading completed"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Slightly slower and more expensive than unit tests but faster than E2E tests."}),"\n",(0,i.jsx)(n.li,{children:"Can include testing at the component level (for example, React components) or the integration between different modules."}),"\n",(0,i.jsx)(n.li,{children:"Verifies that a set of units interact correctly, typically including some level of dependency (like services, databases, or APIs)."}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"4-reasons-component-testing-is-hard--in-angular",children:"4 Reasons Component Testing is Hard ( In Angular)"}),"\n",(0,i.jsx)(n.p,{children:"Mostly all reasons happen because of the need to handle manually processing which in application code are handled for us."}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Configuration of testing module.\nIts something that we cannot just simply eliminate, because we need it to defince which dependencies we want and do not want to mock. The complexity comes from Angular itself because we need to know about relationship of components, how services behave, what is it providing and other possible dependencies."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"Asynchrony.\nIn our test we have to know at which lines of code internally triggering asynchronous tasks because inside of our test we need to manage them, we need to use fakeAsync together with tick or similar approach where we acknowledge the existing async tasks running, run them now synchronously and then we continue.\nIn the application code it works, but in tests we are the ones to manage it."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsx)(n.p,{children:"DOM Interaction.\nIn application code it is handled and works fine, but it causes troubles in our tests depending on how many components we use in one particular test, because some components listen to DOM events to be triggered to work properly."}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:["\n",(0,i.jsxs)(n.p,{children:["Change Detection.\nWe have to trigger it manually ",(0,i.jsx)(n.code,{children:"Fixture.detectChanges"})," otherwise the HTML or the DOM is not up-to-date.\nThere is an option to set change detection automatically, but still it will not work on all situations."]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"end-to-ende2e-test",children:"End-to-End(E2E) Test"}),"\n",(0,i.jsx)(n.p,{children:"E2E Tests the entire application from the user's perspective by simulating real use cases, ensuring all parts of the system work together as intended."}),"\n",(0,i.jsx)(n.p,{children:"Example:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"happy path of user login process, after login was navigated to the dashboard"}),"\n",(0,i.jsx)(n.li,{children:"user in page A with a creation form filled it in correctly, submitted the data and after submitting is redirected correctly to page B and sees latest data as intended"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"Characteristics:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Slow to run and costly to write and maintain because they test the entire stack, including UI, backend, databases, and third-party services."}),"\n",(0,i.jsx)(n.li,{children:"Less frequent but crucial for verifying critical user workflows (e.g., sign-up, purchase flow)."}),"\n",(0,i.jsx)(n.li,{children:"Run against the complete, integrated system and often use browsers or automated tools to simulate user interactions."}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},3353:(e,n,t)=>{t.d(n,{A:()=>s});const s=t.p+"assets/images/testing-pyramid-9d54d2c99341c881cd4fd72c532d0dea.png"},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>r});var s=t(6540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);