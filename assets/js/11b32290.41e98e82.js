"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[8003],{6069:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>d});const a=JSON.parse('{"id":"frontend/angular/design-patterns/structural-patterns/bridge","title":"Bridge","description":"Use case: Decoupling an abstraction from its implementation so that the two can vary independently.","source":"@site/docs/frontend/angular/design-patterns/structural-patterns/bridge.md","sourceDirName":"frontend/angular/design-patterns/structural-patterns","slug":"/frontend/angular/design-patterns/structural-patterns/bridge","permalink":"/av-docs/docs/frontend/angular/design-patterns/structural-patterns/bridge","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/angular/design-patterns/structural-patterns/bridge.md","tags":[],"version":"current","frontMatter":{},"sidebar":"frontendSidebar","previous":{"title":"Adapter","permalink":"/av-docs/docs/frontend/angular/design-patterns/structural-patterns/adapter"},"next":{"title":"Composite","permalink":"/av-docs/docs/frontend/angular/design-patterns/structural-patterns/composite"}}');var r=n(4848),o=n(8453);const s={},i="Bridge",c={},d=[];function p(e){const t={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"bridge",children:"Bridge"})}),"\n",(0,r.jsx)(t.p,{children:"Use case: Decoupling an abstraction from its implementation so that the two can vary independently."}),"\n",(0,r.jsx)(t.p,{children:"Example: Separating component logic from UI implementations (e.g., switching between different themes or UI frameworks)."}),"\n",(0,r.jsx)(t.p,{children:"How to find: Look for scenarios where you can switch implementations at runtime without affecting the abstraction."}),"\n",(0,r.jsx)(t.p,{children:"The Bridge pattern allows you to vary both the abstraction and the implementation independently. In Angular, this can be useful when you have components that can use different services or strategies without changing their core logic."}),"\n",(0,r.jsx)(t.p,{children:"Example Code:"}),"\n",(0,r.jsx)(t.p,{children:"Suppose you have different APIs for fetching data in development and production environments."}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"// data.service.ts\nexport abstract class DataService {\n  abstract getData(): Observable<any>;\n}\n\n// dev-data.service.ts\nimport { Injectable } from '@angular/core';\nimport { of, Observable } from 'rxjs';\nimport { DataService } from './data.service';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class DevDataService extends DataService {\n  getData(): Observable<any> {\n    // Return mock data\n    return of({ data: 'Mock data from DevDataService' });\n  }\n}\n\n// prod-data.service.ts\nimport { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\nimport { DataService } from './data.service';\nimport { Observable } from 'rxjs';\n\n@Injectable({\n  providedIn: 'root',\n})\nexport class ProdDataService extends DataService {\n  constructor(private http: HttpClient) {\n    super();\n  }\n\n  getData(): Observable<any> {\n    return this.http.get('/api/data');\n  }\n}\n\n// app.module.ts\nimport { NgModule } from '@angular/core';\nimport { DataService } from './data.service';\nimport { DevDataService } from './dev-data.service';\nimport { ProdDataService } from './prod-data.service';\nimport { environment } from '../environments/environment';\n\n@NgModule({\n  providers: [\n    {\n      provide: DataService,\n      useClass: environment.production ? ProdDataService : DevDataService,\n    },\n  ],\n  // Other module metadata\n})\nexport class AppModule {}\n\n// data-display.component.ts\nimport { Component, OnInit } from '@angular/core';\nimport { DataService } from './data.service';\n\n@Component({\n  selector: 'app-data-display',\n  template: `<div>{{ data | json }}</div>`,\n})\nexport class DataDisplayComponent implements OnInit {\n  data: any;\n\n  constructor(private dataService: DataService) {}\n\n  ngOnInit() {\n    this.dataService.getData().subscribe((res) => {\n      this.data = res;\n    });\n  }\n}\n"})}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsx)(t.li,{children:"DataService is the abstraction."}),"\n",(0,r.jsx)(t.li,{children:"DevDataService and ProdDataService are implementations."}),"\n",(0,r.jsx)(t.li,{children:"The AppModule bridges the abstraction and implementation by providing the appropriate service based on the environment."}),"\n",(0,r.jsx)(t.li,{children:"DataDisplayComponent uses DataService without needing to know which implementation it is."}),"\n"]})]})}function l(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>i});var a=n(6540);const r={},o=a.createContext(r);function s(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function i(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);