"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[6927],{3584:(t,e,n)=>{n.r(e),n.d(e,{assets:()=>r,contentTitle:()=>c,default:()=>l,frontMatter:()=>s,metadata:()=>a,toc:()=>h});const a=JSON.parse('{"id":"frontend/angular/design-patterns/behavioural-patterns/state","title":"State","description":"Use case: Allowing an object to alter its behavior when its internal state changes.","source":"@site/docs/frontend/angular/design-patterns/behavioural-patterns/state.md","sourceDirName":"frontend/angular/design-patterns/behavioural-patterns","slug":"/frontend/angular/design-patterns/behavioural-patterns/state","permalink":"/av-docs/docs/frontend/angular/design-patterns/behavioural-patterns/state","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/angular/design-patterns/behavioural-patterns/state.md","tags":[],"version":"current","frontMatter":{},"sidebar":"devopsSidebar","previous":{"title":"Observer","permalink":"/av-docs/docs/frontend/angular/design-patterns/behavioural-patterns/observer"},"next":{"title":"Strategy","permalink":"/av-docs/docs/frontend/angular/design-patterns/behavioural-patterns/strategy"}}');var o=n(4848),i=n(8453);const s={},c="State",r={},h=[];function u(t){const e={code:"code",h1:"h1",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,i.R)(),...t.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"state",children:"State"})}),"\n",(0,o.jsx)(e.p,{children:"Use case: Allowing an object to alter its behavior when its internal state changes."}),"\n",(0,o.jsx)(e.p,{children:"Example: Components that change behavior based on the state, such as authentication state."}),"\n",(0,o.jsx)(e.p,{children:"How to find: Look for state machines or objects that change their behavior based on internal state variables."}),"\n",(0,o.jsx)(e.p,{children:"Explanation:"}),"\n",(0,o.jsx)(e.p,{children:"The State pattern allows an object to change its behavior when its internal state changes. The object appears to change its class. In Angular, this can be implemented by having different state classes that the context switches between."}),"\n",(0,o.jsx)(e.p,{children:"Example Code:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-js",children:"// authentication-state.interface.ts\nexport interface AuthenticationState {\n  authenticate(context: AuthenticationContext): void;\n  logout(context: AuthenticationContext): void;\n}\n\n// unauthenticated-state.ts\nimport { AuthenticationState } from './authentication-state.interface';\n\nexport class UnauthenticatedState implements AuthenticationState {\n  authenticate(context: AuthenticationContext): void {\n    console.log('Logging in...');\n    context.setState(new AuthenticatedState());\n  }\n\n  logout(context: AuthenticationContext): void {\n    console.log('Already logged out.');\n  }\n}\n\n// authenticated-state.ts\nimport { AuthenticationState } from './authentication-state.interface';\n\nexport class AuthenticatedState implements AuthenticationState {\n  authenticate(context: AuthenticationContext): void {\n    console.log('Already logged in.');\n  }\n\n  logout(context: AuthenticationContext): void {\n    console.log('Logging out...');\n    context.setState(new UnauthenticatedState());\n  }\n}\n\n// authentication-context.ts\nexport class AuthenticationContext {\n  private state: AuthenticationState;\n\n  constructor() {\n    this.state = new UnauthenticatedState();\n  }\n\n  setState(state: AuthenticationState) {\n    this.state = state;\n  }\n\n  authenticate() {\n    this.state.authenticate(this);\n  }\n\n  logout() {\n    this.state.logout(this);\n  }\n}\n\n// authentication.component.ts\nimport { Component } from '@angular/core';\nimport { AuthenticationContext } from './authentication-context';\n\n@Component({\n  selector: 'app-authentication',\n  template: `\n    <button (click)=\"authenticate()\">Login</button>\n    <button (click)=\"logout()\">Logout</button>\n  `,\n})\nexport class AuthenticationComponent {\n  private authContext = new AuthenticationContext();\n\n  authenticate() {\n    this.authContext.authenticate();\n  }\n\n  logout() {\n    this.authContext.logout();\n  }\n}\n"})}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"AuthenticationState interface defines the methods."}),"\n",(0,o.jsx)(e.li,{children:"AuthenticatedState and UnauthenticatedState implement different behaviors."}),"\n",(0,o.jsx)(e.li,{children:"AuthenticationContext holds the current state and changes behavior accordingly."}),"\n"]})]})}function l(t={}){const{wrapper:e}={...(0,i.R)(),...t.components};return e?(0,o.jsx)(e,{...t,children:(0,o.jsx)(u,{...t})}):u(t)}},8453:(t,e,n)=>{n.d(e,{R:()=>s,x:()=>c});var a=n(6540);const o={},i=a.createContext(o);function s(t){const e=a.useContext(i);return a.useMemo((function(){return"function"==typeof t?t(e):{...e,...t}}),[e,t])}function c(t){let e;return e=t.disableParentContext?"function"==typeof t.components?t.components(o):t.components||o:s(t.components),a.createElement(i.Provider,{value:e},t.children)}}}]);