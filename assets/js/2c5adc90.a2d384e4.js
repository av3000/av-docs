"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[4760],{4460:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"frontend/react/state-management/react-query","title":"TanStack Query (React Query)","description":"Official Resources:","source":"@site/docs/frontend/react/state-management/react-query.md","sourceDirName":"frontend/react/state-management","slug":"/frontend/react/state-management/react-query","permalink":"/av-docs/docs/frontend/react/state-management/react-query","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/react/state-management/react-query.md","tags":[],"version":"current","frontMatter":{},"sidebar":"frontendSidebar","previous":{"title":"Apollo Client","permalink":"/av-docs/docs/frontend/react/state-management/apollo-client"},"next":{"title":"Recoil","permalink":"/av-docs/docs/frontend/react/state-management/recoil"}}');var s=t(4848),i=t(8453);const a={},o="TanStack Query (React Query)",l={},c=[{value:"What is TanStack Query?",id:"what-is-tanstack-query",level:2},{value:"Why TanStack Query?",id:"why-tanstack-query",level:2},{value:"Server State Management Made Simple",id:"server-state-management-made-simple",level:3},{value:"Smart Caching &amp; Background Updates",id:"smart-caching--background-updates",level:3},{value:"Optimistic Updates &amp; Rollbacks",id:"optimistic-updates--rollbacks",level:3},{value:"Built-in Performance Optimizations",id:"built-in-performance-optimizations",level:3},{value:"Declarative Data Dependencies",id:"declarative-data-dependencies",level:3},{value:"Core Principles",id:"core-principles",level:2},{value:"Server State vs Client State",id:"server-state-vs-client-state",level:3},{value:"Queries &amp; Mutations",id:"queries--mutations",level:3},{value:"Caching Strategy",id:"caching-strategy",level:3},{value:"Core Concepts",id:"core-concepts",level:2},{value:"Queries",id:"queries",level:3},{value:"Query Keys",id:"query-keys",level:3},{value:"Mutations",id:"mutations",level:3},{value:"Query Client",id:"query-client",level:3},{value:"Setup",id:"setup",level:2},{value:"Installation &amp; Provider",id:"installation--provider",level:3},{value:"Basic Configuration",id:"basic-configuration",level:3},{value:"Query Patterns",id:"query-patterns",level:2},{value:"Dependent Queries",id:"dependent-queries",level:3},{value:"Parallel Queries",id:"parallel-queries",level:3},{value:"Infinite Queries",id:"infinite-queries",level:3},{value:"Mutation Patterns",id:"mutation-patterns",level:2},{value:"Optimistic Updates",id:"optimistic-updates",level:3},{value:"Global Mutation States",id:"global-mutation-states",level:3},{value:"Advanced Features",id:"advanced-features",level:2},{value:"Query Invalidation",id:"query-invalidation",level:3},{value:"Prefetching",id:"prefetching",level:3},{value:"Background Refetching",id:"background-refetching",level:3},{value:"Error Boundaries &amp; Retry Logic",id:"error-boundaries--retry-logic",level:3},{value:"Server-Side Rendering (SSR)",id:"server-side-rendering-ssr",level:2},{value:"Next.js Integration",id:"nextjs-integration",level:3},{value:"Hydration Boundaries",id:"hydration-boundaries",level:3},{value:"Testing",id:"testing",level:2},{value:"Testing Queries",id:"testing-queries",level:3},{value:"Mocking Mutations",id:"mocking-mutations",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Query Key Factories",id:"query-key-factories",level:3},{value:"Selective Cache Updates",id:"selective-cache-updates",level:3},{value:"Request Deduplication",id:"request-deduplication",level:3},{value:"Best Practices &amp; Patterns",id:"best-practices--patterns",level:2},{value:"Error Handling Strategy",id:"error-handling-strategy",level:3},{value:"Loading States",id:"loading-states",level:3},{value:"Cache Management",id:"cache-management",level:3},{value:"Example Repositories &amp; Resources",id:"example-repositories--resources",level:2},{value:"Official Examples",id:"official-examples",level:3},{value:"Production Examples",id:"production-examples",level:3},{value:"Learning Resources",id:"learning-resources",level:3},{value:"Community Resources",id:"community-resources",level:3},{value:"Integration Examples",id:"integration-examples",level:3},{value:"Project Structure",id:"project-structure",level:3},{value:"Development Workflow",id:"development-workflow",level:3},{value:"Key Benefits",id:"key-benefits",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"tanstack-query-react-query",children:"TanStack Query (React Query)"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.strong,{children:"Official Resources:"})}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tanstack.com/query",children:(0,s.jsx)(n.strong,{children:"TanStack Query"})})," - Official website and documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/TanStack/query",children:(0,s.jsx)(n.strong,{children:"GitHub Repository"})})," - Source code and issues"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tanstack.com/query/latest/docs/framework/react/examples/simple",children:(0,s.jsx)(n.strong,{children:"Examples"})})," - Official example projects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tanstack.com/query/latest/docs/framework/react/guides/migrating-to-v5",children:(0,s.jsx)(n.strong,{children:"Migration Guide"})})," - Upgrading from React Query v3/v4"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"https://tanstack.com/query/latest/docs/framework/react/comparison",children:(0,s.jsx)(n.strong,{children:"Comparison | React Query vs SWR vs Apollo vs RTK Query vs React Router"})})}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"what-is-tanstack-query",children:"What is TanStack Query?"}),"\n",(0,s.jsx)(n.p,{children:"Powerful data synchronization library for web applications. Manages server state, caching, background updates, and synchronization between multiple components seamlessly."}),"\n",(0,s.jsx)(n.h2,{id:"why-tanstack-query",children:"Why TanStack Query?"}),"\n",(0,s.jsx)(n.h3,{id:"server-state-management-made-simple",children:"Server State Management Made Simple"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What"}),": Automatically handles loading states, error states, caching, and background updates for all your API calls\n",(0,s.jsx)(n.strong,{children:"Why"}),": No more useState/useEffect boilerplate. Write one hook, get loading states, error handling, and caching for free."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Before: Manual state management\nconst [user, setUser] = useState(null);\nconst [loading, setLoading] = useState(true);\nconst [error, setError] = useState(null);\n\nuseEffect(() => {\n  fetchUser()\n    .then(setUser)\n    .catch(setError)\n    .finally(() => setLoading(false));\n}, []);\n\n// After: TanStack Query\nconst {\n  data: user,\n  isLoading,\n  error,\n} = useQuery({\n  queryKey: ["user"],\n  queryFn: fetchUser,\n});\n'})}),"\n",(0,s.jsx)(n.h3,{id:"smart-caching--background-updates",children:"Smart Caching & Background Updates"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What"}),": Automatically caches data and refetches in the background when data becomes stale\n",(0,s.jsx)(n.strong,{children:"Why"}),": Your app feels instant while staying fresh. Users see cached data immediately, updates happen behind the scenes."]}),"\n",(0,s.jsx)(n.h3,{id:"optimistic-updates--rollbacks",children:"Optimistic Updates & Rollbacks"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What"}),": Update UI immediately, rollback automatically if the server request fails\n",(0,s.jsx)(n.strong,{children:"Why"}),": Apps feel responsive and snappy. No more waiting for server responses to update the UI."]}),"\n",(0,s.jsx)(n.h3,{id:"built-in-performance-optimizations",children:"Built-in Performance Optimizations"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What"}),": Request deduplication, automatic garbage collection, window focus refetching\n",(0,s.jsx)(n.strong,{children:"Why"}),": Fewer network requests, better performance, always up-to-date data without manual optimization."]}),"\n",(0,s.jsx)(n.h3,{id:"declarative-data-dependencies",children:"Declarative Data Dependencies"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"What"}),": Components automatically re-render when their data changes, pause when data isn't needed\n",(0,s.jsx)(n.strong,{children:"Why"}),": Perfect synchronization across your app. Change user data in one place, see updates everywhere."]}),"\n",(0,s.jsx)(n.h2,{id:"core-principles",children:"Core Principles"}),"\n",(0,s.jsx)(n.h3,{id:"server-state-vs-client-state",children:"Server State vs Client State"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Server state"}),": Data from APIs, databases, external sources"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Client state"}),": UI state, form inputs, toggles, local preferences"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"TanStack Query"}),": Manages server state, letting you focus on client state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Synchronization"}),": Keeps server state in sync across components"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"queries--mutations",children:"Queries & Mutations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Queries"}),": Read operations (GET requests, data fetching)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Mutations"}),": Write operations (POST, PUT, DELETE requests)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Automatic invalidation"}),": Mutations can trigger query refetches"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Optimistic updates"}),": Update UI before server confirms"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"caching-strategy",children:"Caching Strategy"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Cache by key"}),": Each query has a unique key for caching"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Stale-while-revalidate"}),": Show cached data, fetch fresh data in background"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Garbage collection"}),": Automatically cleanup unused cache entries"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Persistence"}),": Optional cache persistence across browser sessions"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"core-concepts",children:"Core Concepts"}),"\n",(0,s.jsx)(n.h3,{id:"queries",children:"Queries"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Fetch and cache data from any asynchronous source\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Automatic loading states, error handling, caching, and background updates"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { useQuery } from "@tanstack/react-query";\n\nfunction UserProfile({ userId }) {\n  const {\n    data: user,\n    isLoading,\n    error,\n    isStale,\n  } = useQuery({\n    queryKey: ["user", userId],\n    queryFn: () => fetchUser(userId),\n    staleTime: 5 * 60 * 1000, // Consider fresh for 5 minutes\n  });\n\n  if (isLoading) return <Spinner />;\n  if (error) return <Error message={error.message} />;\n  return <UserCard user={user} />;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Query keys identify cached data. Include all variables that affect the query result."})}),"\n",(0,s.jsx)(n.h3,{id:"query-keys",children:"Query Keys"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Unique identifiers for cached data\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Automatic cache invalidation, data sharing between components"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Simple key\nuseQuery({ queryKey: ["posts"], queryFn: fetchPosts });\n\n// Key with variables\nuseQuery({ queryKey: ["post", postId], queryFn: () => fetchPost(postId) });\n\n// Complex key with filters\nuseQuery({\n  queryKey: ["posts", { status: "published", author: userId }],\n  queryFn: () => fetchPosts({ status: "published", author: userId }),\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Keys are JSON-serialized arrays. Include all variables that affect the query."})}),"\n",(0,s.jsx)(n.h3,{id:"mutations",children:"Mutations"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Perform side effects (create, update, delete operations)\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Loading states, error handling, optimistic updates, cache invalidation"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { useMutation, useQueryClient } from "@tanstack/react-query";\n\nfunction CreatePost() {\n  const queryClient = useQueryClient();\n\n  const createPost = useMutation({\n    mutationFn: (newPost) => api.createPost(newPost),\n    onSuccess: (data) => {\n      // Invalidate and refetch posts\n      queryClient.invalidateQueries({ queryKey: ["posts"] });\n      // Or add to existing cache\n      queryClient.setQueryData(["post", data.id], data);\n    },\n  });\n\n  const handleSubmit = (postData) => {\n    createPost.mutate(postData);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <button disabled={createPost.isPending}>\n        {createPost.isPending ? "Creating..." : "Create Post"}\n      </button>\n    </form>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Mutations don't cache results but can update the cache manually."})}),"\n",(0,s.jsx)(n.h3,{id:"query-client",children:"Query Client"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Central manager for all queries and cache\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Programmatic cache control, prefetching, manual updates"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { useQueryClient } from "@tanstack/react-query";\n\nfunction UserActions({ userId }) {\n  const queryClient = useQueryClient();\n\n  const refetchUser = () => {\n    queryClient.invalidateQueries({ queryKey: ["user", userId] });\n  };\n\n  const updateUserCache = (updates) => {\n    queryClient.setQueryData(["user", userId], (old) => ({\n      ...old,\n      ...updates,\n    }));\n  };\n\n  const prefetchUserPosts = () => {\n    queryClient.prefetchQuery({\n      queryKey: ["posts", { author: userId }],\n      queryFn: () => fetchUserPosts(userId),\n    });\n  };\n\n  return (\n    <ActionButtons onRefresh={refetchUser} onPrefetch={prefetchUserPosts} />\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Query client provides imperative API for cache management."})}),"\n",(0,s.jsx)(n.h2,{id:"setup",children:"Setup"}),"\n",(0,s.jsx)(n.h3,{id:"installation--provider",children:"Installation & Provider"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Install TanStack Query and wrap your app with QueryClient\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Global cache and configuration for all queries"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install @tanstack/react-query\nnpm install @tanstack/react-query-devtools # Optional dev tools\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { QueryClient, QueryClientProvider } from "@tanstack/react-query";\nimport { ReactQueryDevtools } from "@tanstack/react-query-devtools";\n\n// Create client with default options\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 60 * 1000, // 1 minute\n      retry: 3,\n    },\n  },\n});\n\nfunction App() {\n  return (\n    <QueryClientProvider client={queryClient}>\n      <MyApp />\n      <ReactQueryDevtools initialIsOpen={false} />\n    </QueryClientProvider>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"QueryClientProvider makes the client available to all child components."})}),"\n",(0,s.jsx)(n.h3,{id:"basic-configuration",children:"Basic Configuration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Set global defaults for queries and mutations\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Consistent behavior across your app without repeating options"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 5 * 60 * 1000, // 5 minutes\n      cacheTime: 10 * 60 * 1000, // 10 minutes\n      retry: (failureCount, error) => {\n        if (error.status === 404) return false;\n        return failureCount < 3;\n      },\n      refetchOnWindowFocus: false,\n    },\n    mutations: {\n      retry: 1,\n    },\n  },\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Set sensible defaults based on your app's needs. Override per query when needed."})}),"\n",(0,s.jsx)(n.h2,{id:"query-patterns",children:"Query Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"dependent-queries",children:"Dependent Queries"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Run queries that depend on results from other queries\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Automatic dependency management, efficient data loading"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'function UserPosts({ userId }) {\n  // First query - get user\n  const { data: user } = useQuery({\n    queryKey: ["user", userId],\n    queryFn: () => fetchUser(userId),\n  });\n\n  // Second query - depends on user data\n  const { data: posts } = useQuery({\n    queryKey: ["posts", { author: user?.id }],\n    queryFn: () => fetchUserPosts(user.id),\n    enabled: !!user?.id, // Only run when user is loaded\n  });\n\n  return <PostList posts={posts} />;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsxs)(n.em,{children:["Use ",(0,s.jsx)(n.code,{children:"enabled"})," option to control when queries run based on other data."]})}),"\n",(0,s.jsx)(n.h3,{id:"parallel-queries",children:"Parallel Queries"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Run multiple independent queries simultaneously\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Faster loading by fetching data in parallel"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'function Dashboard() {\n  const userQuery = useQuery({\n    queryKey: ["user"],\n    queryFn: fetchCurrentUser,\n  });\n\n  const postsQuery = useQuery({\n    queryKey: ["posts"],\n    queryFn: fetchRecentPosts,\n  });\n\n  const statsQuery = useQuery({\n    queryKey: ["stats"],\n    queryFn: fetchDashboardStats,\n  });\n\n  // All queries run in parallel\n  if (userQuery.isLoading || postsQuery.isLoading || statsQuery.isLoading) {\n    return <Loading />;\n  }\n\n  return (\n    <div>\n      <UserInfo user={userQuery.data} />\n      <PostsList posts={postsQuery.data} />\n      <Stats data={statsQuery.data} />\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Multiple useQuery calls in the same component run in parallel automatically."})}),"\n",(0,s.jsx)(n.h3,{id:"infinite-queries",children:"Infinite Queries"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),': Load paginated data with "load more" functionality\n',(0,s.jsx)(n.strong,{children:"Benefit"}),": Automatic page management, infinite scrolling, optimized UX"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { useInfiniteQuery } from "@tanstack/react-query";\n\nfunction PostsList() {\n  const { data, fetchNextPage, hasNextPage, isFetchingNextPage } =\n    useInfiniteQuery({\n      queryKey: ["posts"],\n      queryFn: ({ pageParam = 0 }) => fetchPosts({ page: pageParam }),\n      getNextPageParam: (lastPage, pages) => {\n        return lastPage.hasMore ? pages.length : undefined;\n      },\n    });\n\n  const allPosts = data?.pages.flatMap((page) => page.posts) ?? [];\n\n  return (\n    <div>\n      {allPosts.map((post) => (\n        <PostCard key={post.id} post={post} />\n      ))}\n\n      <button\n        onClick={fetchNextPage}\n        disabled={!hasNextPage || isFetchingNextPage}\n      >\n        {isFetchingNextPage ? "Loading..." : "Load More"}\n      </button>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Infinite queries handle pagination automatically. Pages are cached separately."})}),"\n",(0,s.jsx)(n.h2,{id:"mutation-patterns",children:"Mutation Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Update UI immediately, rollback if server request fails\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Instant feedback, better perceived performance"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'function ToggleLike({ postId, initialLiked }) {\n  const queryClient = useQueryClient();\n\n  const toggleLike = useMutation({\n    mutationFn: (liked) => api.updatePost(postId, { liked }),\n\n    // Optimistically update before request\n    onMutate: async (newLiked) => {\n      // Cancel outgoing refetches\n      await queryClient.cancelQueries({ queryKey: ["post", postId] });\n\n      // Snapshot current value\n      const previousPost = queryClient.getQueryData(["post", postId]);\n\n      // Optimistically update\n      queryClient.setQueryData(["post", postId], (old) => ({\n        ...old,\n        liked: newLiked,\n        likeCount: old.likeCount + (newLiked ? 1 : -1),\n      }));\n\n      return { previousPost };\n    },\n\n    // Rollback on error\n    onError: (err, newLiked, context) => {\n      queryClient.setQueryData(["post", postId], context.previousPost);\n    },\n\n    // Refetch on success or error\n    onSettled: () => {\n      queryClient.invalidateQueries({ queryKey: ["post", postId] });\n    },\n  });\n\n  return (\n    <button onClick={() => toggleLike.mutate(!initialLiked)}>\n      {initialLiked ? "\u2764\ufe0f" : "\ud83e\udd0d"}\n    </button>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Optimistic updates make apps feel instant while maintaining data consistency."})}),"\n",(0,s.jsx)(n.h3,{id:"global-mutation-states",children:"Global Mutation States"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Share mutation loading states across components\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Global loading indicators, disable forms during mutations"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { useIsMutating } from "@tanstack/react-query";\n\nfunction GlobalLoadingIndicator() {\n  const isMutating = useIsMutating();\n\n  if (isMutating) {\n    return <div className="global-spinner">Saving...</div>;\n  }\n\n  return null;\n}\n\n// Or check specific mutation types\nfunction SaveIndicator() {\n  const isSaving = useIsMutating({ mutationKey: ["updatePost"] });\n  return isSaving ? <Spinner /> : null;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Track mutations globally for better UX coordination."})}),"\n",(0,s.jsx)(n.h2,{id:"advanced-features",children:"Advanced Features"}),"\n",(0,s.jsx)(n.h3,{id:"query-invalidation",children:"Query Invalidation"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Mark cached data as stale and trigger refetches\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Keep data fresh after mutations, selective cache updates"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const queryClient = useQueryClient();\n\n// Invalidate specific query\nqueryClient.invalidateQueries({ queryKey: ["post", postId] });\n\n// Invalidate all posts\nqueryClient.invalidateQueries({ queryKey: ["posts"] });\n\n// Invalidate with partial matching\nqueryClient.invalidateQueries({\n  queryKey: ["posts"],\n  exact: false, // Invalidates [\'posts\', ...anything]\n});\n\n// Invalidate with predicate\nqueryClient.invalidateQueries({\n  predicate: (query) =>\n    query.queryKey[0] === "posts" && query.queryKey[1]?.author === userId,\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Invalidation strategies help maintain data consistency across your app."})}),"\n",(0,s.jsx)(n.h3,{id:"prefetching",children:"Prefetching"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Load data before it's needed\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Instant navigation, better user experience"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'function PostCard({ post }) {\n  const queryClient = useQueryClient();\n\n  const handleMouseEnter = () => {\n    // Prefetch full post on hover\n    queryClient.prefetchQuery({\n      queryKey: ["post", post.id],\n      queryFn: () => fetchFullPost(post.id),\n      staleTime: 10 * 1000, // Only prefetch if not already fresh\n    });\n  };\n\n  return (\n    <div onMouseEnter={handleMouseEnter}>\n      <Link to={`/posts/${post.id}`}>\n        <h3>{post.title}</h3>\n      </Link>\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Prefetch data on user interactions for perceived instant loading."})}),"\n",(0,s.jsx)(n.h3,{id:"background-refetching",children:"Background Refetching"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Keep data fresh without showing loading states\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Always current data without disrupting user experience"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Automatic background refetching\nconst { data: posts } = useQuery({\n  queryKey: ["posts"],\n  queryFn: fetchPosts,\n  staleTime: 30 * 1000, // Fresh for 30 seconds\n  refetchInterval: 60 * 1000, // Background refetch every minute\n  refetchOnWindowFocus: true, // Refetch when user returns to tab\n  refetchOnReconnect: true, // Refetch when internet reconnects\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Configure automatic refetching based on your data's update frequency."})}),"\n",(0,s.jsx)(n.h3,{id:"error-boundaries--retry-logic",children:"Error Boundaries & Retry Logic"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Handle errors gracefully with automatic retries\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Resilient apps that recover from network issues"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const { data, error, isError } = useQuery({\n  queryKey: ["posts"],\n  queryFn: fetchPosts,\n  retry: (failureCount, error) => {\n    // Don\'t retry on 4xx errors\n    if (error.status >= 400 && error.status < 500) return false;\n    // Retry up to 3 times for other errors\n    return failureCount < 3;\n  },\n  retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),\n});\n\n// Global error boundary for React Query errors\nfunction QueryErrorBoundary({ children }) {\n  return (\n    <ErrorBoundary\n      onError={(error, errorInfo) => {\n        if (error.name === "ChunkLoadError") {\n          window.location.reload();\n        }\n      }}\n      fallback={<ErrorFallback />}\n    >\n      {children}\n    </ErrorBoundary>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Smart retry logic and error boundaries make your app more resilient."})}),"\n",(0,s.jsx)(n.h2,{id:"server-side-rendering-ssr",children:"Server-Side Rendering (SSR)"}),"\n",(0,s.jsx)(n.h3,{id:"nextjs-integration",children:"Next.js Integration"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Hydrate client with server-fetched data\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": SEO-friendly, faster initial page loads"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// pages/posts/[id].js\nimport { dehydrate, QueryClient, useQuery } from "@tanstack/react-query";\n\nexport async function getServerSideProps({ params }) {\n  const queryClient = new QueryClient();\n\n  await queryClient.prefetchQuery({\n    queryKey: ["post", params.id],\n    queryFn: () => fetchPost(params.id),\n  });\n\n  return {\n    props: {\n      dehydratedState: dehydrate(queryClient),\n    },\n  };\n}\n\nfunction PostPage({ postId }) {\n  // This will use the prefetched data\n  const { data: post } = useQuery({\n    queryKey: ["post", postId],\n    queryFn: () => fetchPost(postId),\n  });\n\n  return <PostDetail post={post} />;\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Server-side prefetching eliminates loading states on initial page load."})}),"\n",(0,s.jsx)(n.h3,{id:"hydration-boundaries",children:"Hydration Boundaries"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Handle SSR/client hydration mismatches\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Prevent hydration errors while maintaining SSR benefits"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { Hydrate } from "@tanstack/react-query";\n\nfunction MyApp({ Component, pageProps }) {\n  const [queryClient] = useState(() => new QueryClient());\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      <Hydrate state={pageProps.dehydratedState}>\n        <Component {...pageProps} />\n      </Hydrate>\n    </QueryClientProvider>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Hydrate component ensures smooth transition from server to client state."})}),"\n",(0,s.jsx)(n.h2,{id:"testing",children:"Testing"}),"\n",(0,s.jsx)(n.h3,{id:"testing-queries",children:"Testing Queries"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Test components that use TanStack Query\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Reliable tests that cover real data fetching scenarios"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'import { QueryClient, QueryClientProvider } from "@tanstack/react-query";\nimport { render, screen, waitFor } from "@testing-library/react";\n\nfunction renderWithClient(ui) {\n  const testQueryClient = new QueryClient({\n    defaultOptions: {\n      queries: { retry: false },\n      mutations: { retry: false },\n    },\n  });\n\n  return render(\n    <QueryClientProvider client={testQueryClient}>{ui}</QueryClientProvider>\n  );\n}\n\ntest("displays user data", async () => {\n  // Mock the API\n  vi.mocked(fetchUser).mockResolvedValue({ id: "1", name: "John" });\n\n  renderWithClient(<UserProfile userId="1" />);\n\n  expect(screen.getByText("Loading...")).toBeInTheDocument();\n\n  await waitFor(() => {\n    expect(screen.getByText("John")).toBeInTheDocument();\n  });\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Create test-specific QueryClient with retry disabled for predictable tests."})}),"\n",(0,s.jsx)(n.h3,{id:"mocking-mutations",children:"Mocking Mutations"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Test mutation behavior without making real API calls\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Fast, reliable tests for user interactions"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'test("creates post on form submission", async () => {\n  const mockMutate = vi.fn();\n  vi.mocked(useMutation).mockReturnValue({\n    mutate: mockMutate,\n    isPending: false,\n    isError: false,\n  });\n\n  renderWithClient(<CreatePostForm />);\n\n  await user.type(screen.getByLabelText("Title"), "New Post");\n  await user.click(screen.getByRole("button", { name: "Create" }));\n\n  expect(mockMutate).toHaveBeenCalledWith({\n    title: "New Post",\n  });\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Mock mutations to test UI behavior without side effects."})}),"\n",(0,s.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,s.jsx)(n.h3,{id:"query-key-factories",children:"Query Key Factories"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Consistent query keys across your app\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Easier invalidation, less typos, better organization"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:"// utils/queryKeys.js\nexport const postKeys = {\n  all: ['posts'] as const,\n  lists: () => [...postKeys.all, 'list'] as const,\n  list: (filters: string) => [...postKeys.lists(), { filters }] as const,\n  details: () => [...postKeys.all, 'detail'] as const,\n  detail: (id: string) => [...postKeys.details(), id] as const,\n};\n\n// Usage\nuseQuery({\n  queryKey: postKeys.detail(postId),\n  queryFn: () => fetchPost(postId),\n});\n\n// Invalidation\nqueryClient.invalidateQueries({ queryKey: postKeys.lists() });\n"})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Centralized key management prevents inconsistencies and simplifies cache operations."})}),"\n",(0,s.jsx)(n.h3,{id:"selective-cache-updates",children:"Selective Cache Updates"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Update specific cached data without full refetches\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Better performance, maintain scroll positions, preserve form state"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'const updatePost = useMutation({\n  mutationFn: updatePostApi,\n  onSuccess: (updatedPost) => {\n    // Update individual post cache\n    queryClient.setQueryData(["post", updatedPost.id], updatedPost);\n\n    // Update post in lists\n    queryClient.setQueryData(["posts"], (old) =>\n      old?.map((post) => (post.id === updatedPost.id ? updatedPost : post))\n    );\n  },\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Surgical cache updates avoid unnecessary network requests and UI flicker."})}),"\n",(0,s.jsx)(n.h3,{id:"request-deduplication",children:"Request Deduplication"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Prevent duplicate requests for the same data\n",(0,s.jsx)(n.strong,{children:"Benefit"}),": Reduced server load, faster response times"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Multiple components can use the same query key\nfunction UserProfile({ userId }) {\n  const { data: user } = useQuery({\n    queryKey: ["user", userId],\n    queryFn: () => fetchUser(userId),\n  });\n  // Only one request will be made, even if multiple components mount\n}\n\nfunction UserPosts({ userId }) {\n  const { data: user } = useQuery({\n    queryKey: ["user", userId], // Same key = same cached data\n    queryFn: () => fetchUser(userId),\n  });\n  // This will use the cached result from UserProfile\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"TanStack Query automatically deduplicates requests with identical query keys."})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices--patterns",children:"Best Practices & Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"error-handling-strategy",children:"Error Handling Strategy"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Consistent error handling across your application\n",(0,s.jsx)(n.strong,{children:"Pattern"}),": Global error handler with component-specific overrides"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Global error handler\nconst queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      onError: (error) => {\n        if (error.status === 401) {\n          redirectToLogin();\n        } else if (error.status >= 500) {\n          showGlobalErrorToast("Server error. Please try again.");\n        }\n      },\n    },\n  },\n});\n\n// Component-specific error handling\nconst { data, error } = useQuery({\n  queryKey: ["user", userId],\n  queryFn: fetchUser,\n  onError: (error) => {\n    // Handle user-specific errors\n    if (error.status === 404) {\n      navigate("/user-not-found");\n    }\n  },\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Combine global and local error handling for comprehensive coverage."})}),"\n",(0,s.jsx)(n.h3,{id:"loading-states",children:"Loading States"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Provide appropriate feedback for different loading scenarios\n",(0,s.jsx)(n.strong,{children:"Pattern"}),": Distinguish between initial loading and background refetching"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'function PostList() {\n  const {\n    data: posts,\n    isLoading,\n    isFetching,\n    error,\n  } = useQuery({\n    queryKey: ["posts"],\n    queryFn: fetchPosts,\n  });\n\n  if (isLoading) {\n    // First time loading\n    return <PostListSkeleton />;\n  }\n\n  if (error) {\n    return <ErrorMessage error={error} />;\n  }\n\n  return (\n    <div>\n      {isFetching && <RefreshIndicator />}\n      <PostGrid posts={posts} />\n    </div>\n  );\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Different loading states provide better user experience and context."})}),"\n",(0,s.jsx)(n.h3,{id:"cache-management",children:"Cache Management"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Purpose"}),": Optimize memory usage and data freshness\n",(0,s.jsx)(n.strong,{children:"Pattern"}),": Configure cache times based on data volatility"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-jsx",children:'// Frequently changing data\nconst { data: notifications } = useQuery({\n  queryKey: ["notifications"],\n  queryFn: fetchNotifications,\n  staleTime: 0, // Always considered stale\n  cacheTime: 5 * 60 * 1000, // Keep in cache for 5 minutes\n});\n\n// Rarely changing data\nconst { data: userSettings } = useQuery({\n  queryKey: ["user-settings"],\n  queryFn: fetchUserSettings,\n  staleTime: 60 * 60 * 1000, // Fresh for 1 hour\n  cacheTime: 24 * 60 * 60 * 1000, // Keep for 24 hours\n});\n'})}),"\n",(0,s.jsx)(n.p,{children:(0,s.jsx)(n.em,{children:"Match cache configuration to your data's update frequency and importance."})}),"\n",(0,s.jsx)(n.h2,{id:"example-repositories--resources",children:"Example Repositories & Resources"}),"\n",(0,s.jsx)(n.h3,{id:"official-examples",children:"Official Examples"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tanstack.com/query/latest/docs/framework/react/examples/simple",children:(0,s.jsx)(n.strong,{children:"TanStack Query Examples"})})," - Official example projects"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/TanStack/query",children:(0,s.jsx)(n.strong,{children:"TanStack Query GitHub"})})," - Source code with comprehensive examples"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://ui.dev/c/react-query",children:(0,s.jsx)(n.strong,{children:"React Query Essentials Course"})})," - Official learning course"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"production-examples",children:"Production Examples"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/calcom/cal.com",children:(0,s.jsx)(n.strong,{children:"Cal.com"})})," - Uses TanStack Query with tRPC for type-safe data fetching"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/alan2207/bulletproof-react",children:(0,s.jsx)(n.strong,{children:"Bulletproof React"})})," - Production architecture with TanStack Query"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/shadcn/taxonomy",children:(0,s.jsx)(n.strong,{children:"Taxonomy"})})," - Next.js 13 app using TanStack Query"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/t3-oss/create-t3-app",children:(0,s.jsx)(n.strong,{children:"T3 Stack Examples"})})," - TanStack Query + tRPC integration"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"learning-resources",children:"Learning Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tanstack.com/query/latest",children:(0,s.jsx)(n.strong,{children:"TanStack Query Docs"})})," - Comprehensive official documentation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://www.youtube.com/watch?v=novnyCaa7To",children:(0,s.jsx)(n.strong,{children:"React Query in 100 Seconds"})})," - Quick overview video"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tkdodo.eu/blog/practical-react-query",children:(0,s.jsx)(n.strong,{children:"TkDodo's Blog"})})," - In-depth React Query articles"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tkdodo.eu/blog/effective-react-query-keys",children:(0,s.jsx)(n.strong,{children:"Query Key Factory Pattern"})})," - Advanced key management"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"community-resources",children:"Community Resources"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/TanStack/query/tree/main/packages/react-query-devtools",children:(0,s.jsx)(n.strong,{children:"React Query DevTools"})})," - Essential debugging tools"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/tannerlinsley/react-query/tree/master/examples",children:(0,s.jsx)(n.strong,{children:"React Query Examples Collection"})})," - Community examples"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/sadeghbarati/awesome-react-query",children:(0,s.jsx)(n.strong,{children:"Awesome React Query"})})," - Curated resources and articles"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"integration-examples",children:"Integration Examples"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/vercel/next.js/tree/canary/examples/with-react-query",children:(0,s.jsx)(n.strong,{children:"Next.js + React Query"})})," - SSR integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://github.com/pmndrs/zustand/blob/main/docs/integrations/persisting-store-data.md",children:(0,s.jsx)(n.strong,{children:"React Query + Zustand"})})," - State management combo"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://react-hook-form.com/advanced-usage#ConnectwithReactQuery",children:(0,s.jsx)(n.strong,{children:"React Query + React Hook Form"})})," - Forms integration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"https://tanstack.com/query/latest/docs/framework/react/examples/load-more-infinite-scroll",children:(0,s.jsx)(n.strong,{children:"React Query + Infinite Scroll"})})," - Pagination patterns"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"project-structure",children:"Project Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"src/\n\u251c\u2500\u2500 api/                    # API functions\n\u2502   \u251c\u2500\u2500 posts.js\n\u2502   \u251c\u2500\u2500 users.js\n\u2502   \u2514\u2500\u2500 queryKeys.js       # Centralized query keys\n\u251c\u2500\u2500 hooks/                 # Custom query hooks\n\u2502   \u251c\u2500\u2500 usePosts.js\n\u2502   \u251c\u2500\u2500 useUsers.js\n\u2502   \u2514\u2500\u2500 mutations/\n\u2502       \u251c\u2500\u2500 useCreatePost.js\n\u2502       \u2514\u2500\u2500 useUpdateUser.js\n\u251c\u2500\u2500 components/\n\u251c\u2500\u2500 pages/\n\u2514\u2500\u2500 utils/\n    \u251c\u2500\u2500 queryClient.js     # Query client setup\n    \u2514\u2500\u2500 api.js            # Base API configuration\n"})}),"\n",(0,s.jsx)(n.h3,{id:"development-workflow",children:"Development Workflow"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Define API functions"})," in separate modules"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Create custom hooks"})," that wrap useQuery/useMutation"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Establish query key patterns"})," for consistent cache management"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Set up global defaults"})," in QueryClient configuration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Use React Query DevTools"})," for debugging and optimization"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\udd04 Automatic Synchronization"}),": Server state stays in sync across all components"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\u26a1 Performance"}),": Smart caching, request deduplication, background updates"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83c\udfaf Developer Experience"}),": Eliminates useState/useEffect boilerplate for server state"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\udee1\ufe0f Resilience"}),": Built-in retry logic, error handling, and offline support"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\ude80 User Experience"}),": Optimistic updates, instant navigation with prefetching"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"\ud83d\udcca Observability"}),": Excellent dev tools for debugging and cache inspection"]}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);