"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[5285],{3776:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>a,toc:()=>c});const a=JSON.parse('{"id":"frontend/react/state-management/apollo-client","title":"Apollo Client","description":"apollographql.com/docs/react","source":"@site/docs/frontend/react/state-management/apollo-client.md","sourceDirName":"frontend/react/state-management","slug":"/frontend/react/state-management/apollo-client","permalink":"/av-docs/docs/frontend/react/state-management/apollo-client","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/react/state-management/apollo-client.md","tags":[],"version":"current","frontMatter":{},"sidebar":"frontendSidebar","previous":{"title":"Intro","permalink":"/av-docs/docs/frontend/react/"},"next":{"title":"TanStack Query (React Query)","permalink":"/av-docs/docs/frontend/react/state-management/react-query"}}');var r=t(4848),s=t(8453);const i={},o="Apollo Client",l={},c=[{value:"Why Apollo Client over Fetch/Axios?",id:"why-apollo-client-over-fetchaxios",level:2},{value:"Key Benefits",id:"key-benefits",level:2},{value:"Example Repositories",id:"example-repositories",level:2},{value:"Official &amp; Tutorial Examples",id:"official--tutorial-examples",level:3},{value:"GitHub API Integration Examples",id:"github-api-integration-examples",level:3},{value:"TypeScript &amp; Full-Stack Examples",id:"typescript--full-stack-examples",level:3},{value:"Key Features Demonstrated",id:"key-features-demonstrated",level:3},{value:"The Fetch Problem - Manual State Management",id:"the-fetch-problem---manual-state-management",level:3},{value:"Apollo Solution - Declarative Data Management",id:"apollo-solution---declarative-data-management",level:3},{value:"Minimal Setup - 3 Steps",id:"minimal-setup---3-steps",level:2},{value:"Advanced Setup (with Auth &amp; Type Policies)",id:"advanced-setup-with-auth--type-policies",level:2},{value:"Basic Queries",id:"basic-queries",level:2},{value:"Mutations",id:"mutations",level:2},{value:"Optimistic Updates",id:"optimistic-updates",level:2},{value:"Subscriptions (Real-time Updates)",id:"subscriptions-real-time-updates",level:2},{value:"Error Handling",id:"error-handling",level:2},{value:"Pagination",id:"pagination",level:2},{value:"Local State Management",id:"local-state-management",level:2},{value:"Cache Management",id:"cache-management",level:2},{value:"Developer Tools",id:"developer-tools",level:2},{value:"Type Safety with Code Generation",id:"type-safety-with-code-generation",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"apollo-client",children:"Apollo Client"})}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.a,{href:"https://www.apollographql.com/docs/react",children:"apollographql.com/docs/react"})}),"\n",(0,r.jsx)(n.h2,{id:"why-apollo-client-over-fetchaxios",children:"Why Apollo Client over Fetch/Axios?"}),"\n",(0,r.jsx)(n.p,{children:"Traditional REST API calls with fetch/axios require manual state management for loading states, error handling, and caching. Apollo Client provides declarative data fetching with automatic caching, optimistic updates, and real-time subscriptions out of the box."}),"\n",(0,r.jsx)(n.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#minimal-setup---3-steps",children:"Declarative data fetching"})}),": Describe what data you need, not how to fetch it"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#cache-management",children:"Automatic caching"})}),": Intelligent cache that shares data across components"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#subscriptions-real-time-updates",children:"Real-time updates"})}),": Subscriptions for live data without manual polling"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#optimistic-updates",children:"Optimistic UI"})}),": Immediate feedback before server confirmation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#error-handling",children:"Error handling"})}),": Built-in error states and recovery mechanisms"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#developer-tools",children:"Developer tools"})}),": Excellent debugging with Apollo DevTools"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#type-safety-with-code-generation",children:"Type safety"})}),": Full TypeScript support with generated types"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#cache-management",children:"Offline support"})}),": Cache-first strategies work without network"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"#cache-management",children:"Performance"})}),": Request deduplication and automatic batching"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"example-repositories",children:"Example Repositories"}),"\n",(0,r.jsx)(n.p,{children:"Here are excellent Apollo Client + React example repositories:"}),"\n",(0,r.jsx)(n.h3,{id:"official--tutorial-examples",children:"Official & Tutorial Examples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://github.com/howtographql/react-apollo",children:"HowToGraphQL React Apollo Tutorial"})})," - Complete step-by-step tutorial with both client and server setup. Perfect for beginners learning the full GraphQL stack."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://github.com/apollographql/apollo-client",children:"Apollo Client Main Repository"})})," - Official Apollo Client repo with comprehensive examples and latest features."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"github-api-integration-examples",children:"GitHub API Integration Examples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://github.com/the-road-to-graphql/react-graphql-github-apollo",children:"React GraphQL GitHub Apollo"})})," - Full-featured GitHub client demonstrating real-world Apollo patterns with authentication, queries, mutations, and UI components."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://github.com/the-road-to-graphql/react-apollo-client-example",children:"React Apollo Client Example"})})," - Minimal boilerplate showing Apollo for remote data + React state for local data. Great starting point for new projects."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://github.com/dipiash/react-apollo-github-top-js-repos",children:"GitHub Top JS Repos"})})," - Clean example with hooks, testing, and modern patterns. Includes search, filtering, and pagination."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"typescript--full-stack-examples",children:"TypeScript & Full-Stack Examples"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:(0,r.jsx)(n.a,{href:"https://github.com/colebemis/dasher",children:"Dasher (Cole Bemis)"})})," - Production-ready example with React + TypeScript + GraphQL Code Generator. Shows advanced patterns like fragments and optimized queries."]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"key-features-demonstrated",children:"Key Features Demonstrated"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"\u2705 Apollo Client setup and configuration"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 useQuery, useMutation, useSubscription hooks"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 TypeScript integration with code generation"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Authentication and error handling"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Cache management and optimistic updates"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Real-time subscriptions"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Pagination and infinite loading"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Testing strategies"}),"\n",(0,r.jsx)(n.li,{children:"\u2705 Project structure and best practices"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"the-fetch-problem---manual-state-management",children:"The Fetch Problem - Manual State Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// Problem: Manual loading states, error handling, and caching\nfunction UsersList() {\n  const [users, setUsers] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  const fetchUsers = async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      const response = await fetch("/api/users");\n      if (!response.ok) throw new Error("Failed to fetch");\n      const data = await response.json();\n      setUsers(data);\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  useEffect(() => {\n    fetchUsers();\n  }, []);\n\n  const createUser = async (userData) => {\n    setLoading(true);\n    try {\n      const response = await fetch("/api/users", {\n        method: "POST",\n        headers: { "Content-Type": "application/json" },\n        body: JSON.stringify(userData),\n      });\n      const newUser = await response.json();\n\n      // Manual cache update - easy to forget or mess up\n      setUsers((prev) => [...prev, newUser]);\n\n      // Need to refetch to ensure consistency\n      await fetchUsers();\n    } catch (err) {\n      setError(err.message);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  // Problems:\n  // 1. Repetitive loading/error state management\n  // 2. Manual cache invalidation\n  // 3. No optimistic updates\n  // 4. Race conditions possible\n  // 5. No real-time updates\n  // 6. Data duplicated across components\n}\n'})}),"\n",(0,r.jsx)(n.h3,{id:"apollo-solution---declarative-data-management",children:"Apollo Solution - Declarative Data Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// Solution: Declarative queries with automatic caching\nfunction UsersList() {\n  const { data, loading, error, refetch } = useQuery(GET_USERS);\n  const [createUser] = useMutation(CREATE_USER, {\n    update: (cache, { data: { createUser } }) => {\n      // Automatic cache update\n      cache.modify({\n        fields: {\n          users(existingUsers = []) {\n            return [...existingUsers, createUser];\n          },\n        },\n      });\n    },\n  });\n\n  // Automatic loading states, error handling, and caching\n  // Optimistic updates and real-time subscriptions available\n  // Data shared across all components automatically\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"minimal-setup---3-steps",children:"Minimal Setup - 3 Steps"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// Install: npm install @apollo/client graphql\n\n// 1. Create client\nimport { ApolloClient, InMemoryCache } from "@apollo/client";\n\nexport const client = new ApolloClient({\n  uri: "https://api.github.com/graphql",\n  cache: new InMemoryCache(),\n});\n\n// 2. Create query hook\nimport { useQuery, gql } from "@apollo/client";\n\nconst exchangeRatesQuery = gql`\n  query GetExchangeRates {\n    rates(currency: "USD") {\n      currency\n      rate\n    }\n  }\n`;\n\nexport const useExchangeRates = () => useQuery(exchangeRatesQuery);\n\n// 3. Use in component\nimport React from "react";\nimport { ApolloProvider } from "@apollo/client";\nimport { client as apolloClient } from "./apolloClient";\nimport { useExchangeRates } from "./hooks/useExchangeRates";\n\nexport const App = () => {\n  const { data, loading } = useExchangeRates();\n\n  if (loading) return <div>Loading...</div>;\n  if (!data) return <div>No data</div>;\n\n  return (\n    <div>\n      {data.rates.map((rate) => (\n        <div key={rate.currency}>\n          {rate.currency}: {rate.rate}\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport const AppContainer = () => {\n  return (\n    <ApolloProvider client={apolloClient}>\n      <App />\n    </ApolloProvider>\n  );\n};\n'})}),"\n",(0,r.jsx)(n.h2,{id:"advanced-setup-with-auth--type-policies",children:"Advanced Setup (with Auth & Type Policies)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// apollo-client.ts\nimport { ApolloClient, InMemoryCache, createHttpLink } from "@apollo/client";\nimport { setContext } from "@apollo/client/link/context";\n\nconst httpLink = createHttpLink({\n  uri: "http://localhost:4000/graphql",\n});\n\nconst authLink = setContext((_, { headers }) => {\n  const token = localStorage.getItem("token");\n  return {\n    headers: {\n      ...headers,\n      authorization: token ? `Bearer ${token}` : "",\n    },\n  };\n});\n\nexport const client = new ApolloClient({\n  link: authLink.concat(httpLink),\n  cache: new InMemoryCache({\n    typePolicies: {\n      User: {\n        fields: {\n          posts: {\n            merge(existing = [], incoming) {\n              return [...existing, ...incoming];\n            },\n          },\n        },\n      },\n    },\n  }),\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"basic-queries",children:"Basic Queries"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// queries/users.ts\nimport { gql } from "@apollo/client";\n\nexport const GET_USERS = gql`\n  query GetUsers {\n    users {\n      id\n      name\n      email\n      avatar\n      createdAt\n    }\n  }\n`;\n\nexport const GET_USER = gql`\n  query GetUser($id: ID!) {\n    user(id: $id) {\n      id\n      name\n      email\n      avatar\n      bio\n      posts {\n        id\n        title\n        createdAt\n      }\n    }\n  }\n`;\n\n// Component usage\nimport { useQuery } from "@apollo/client";\n\nfunction UsersList() {\n  const { data, loading, error, refetch } = useQuery(GET_USERS);\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <div>\n      <button onClick={() => refetch()}>Refresh</button>\n      {data.users.map((user) => (\n        <div key={user.id}>\n          <img src={user.avatar} alt={user.name} />\n          <h3>{user.name}</h3>\n          <p>{user.email}</p>\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// Query with variables\nfunction UserProfile({ userId }) {\n  const { data, loading, error } = useQuery(GET_USER, {\n    variables: { id: userId },\n    skip: !userId, // Skip query if no userId\n    errorPolicy: "all", // Return partial data on error\n    fetchPolicy: "cache-first", // Use cache if available\n  });\n\n  if (loading) return <div>Loading user...</div>;\n  if (error) return <div>Error loading user: {error.message}</div>;\n  if (!data?.user) return <div>User not found</div>;\n\n  return (\n    <div>\n      <h1>{data.user.name}</h1>\n      <p>{data.user.bio}</p>\n      <div>\n        <h2>Posts ({data.user.posts.length})</h2>\n        {data.user.posts.map((post) => (\n          <div key={post.id}>{post.title}</div>\n        ))}\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"mutations",children:"Mutations"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// mutations/users.ts\nimport { gql } from "@apollo/client";\n\nexport const CREATE_USER = gql`\n  mutation CreateUser($input: CreateUserInput!) {\n    createUser(input: $input) {\n      id\n      name\n      email\n      avatar\n      createdAt\n    }\n  }\n`;\n\nexport const UPDATE_USER = gql`\n  mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {\n    updateUser(id: $id, input: $input) {\n      id\n      name\n      email\n      bio\n      avatar\n    }\n  }\n`;\n\nexport const DELETE_USER = gql`\n  mutation DeleteUser($id: ID!) {\n    deleteUser(id: $id) {\n      id\n    }\n  }\n`;\n\n// Component usage\nimport { useMutation } from "@apollo/client";\n\nfunction CreateUserForm() {\n  const [createUser, { loading, error }] = useMutation(CREATE_USER, {\n    // Update cache after mutation\n    update: (cache, { data: { createUser } }) => {\n      cache.modify({\n        fields: {\n          users(existingUsers = []) {\n            const newUserRef = cache.writeFragment({\n              data: createUser,\n              fragment: gql`\n                fragment NewUser on User {\n                  id\n                  name\n                  email\n                  avatar\n                  createdAt\n                }\n              `,\n            });\n            return [...existingUsers, newUserRef];\n          },\n        },\n      });\n    },\n    // Refetch queries after mutation\n    refetchQueries: [{ query: GET_USERS }],\n    onCompleted: (data) => {\n      console.log("User created:", data.createUser);\n    },\n    onError: (error) => {\n      console.error("Failed to create user:", error);\n    },\n  });\n\n  const handleSubmit = async (formData) => {\n    try {\n      const { data } = await createUser({\n        variables: { input: formData },\n      });\n      // Handle success\n    } catch (err) {\n      // Error already handled by onError\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {/* form fields */}\n      <button type="submit" disabled={loading}>\n        {loading ? "Creating..." : "Create User"}\n      </button>\n      {error && <div>Error: {error.message}</div>}\n    </form>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"optimistic-updates",children:"Optimistic Updates"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// Optimistic UI - immediate feedback before server response\nfunction LikeButton({ postId, isLiked, likeCount }) {\n  const [toggleLike] = useMutation(TOGGLE_LIKE, {\n    variables: { postId },\n    optimisticResponse: {\n      toggleLike: {\n        __typename: "Post",\n        id: postId,\n        isLiked: !isLiked,\n        likeCount: isLiked ? likeCount - 1 : likeCount + 1,\n      },\n    },\n    update: (cache, { data: { toggleLike } }) => {\n      cache.modify({\n        id: cache.identify({ __typename: "Post", id: postId }),\n        fields: {\n          isLiked: () => toggleLike.isLiked,\n          likeCount: () => toggleLike.likeCount,\n        },\n      });\n    },\n  });\n\n  return (\n    <button onClick={() => toggleLike()}>\n      {isLiked ? "\u2764\ufe0f" : "\ud83e\udd0d"} {likeCount}\n    </button>\n  );\n}\n\n// Delete with optimistic update\nfunction DeletePostButton({ postId }) {\n  const [deletePost] = useMutation(DELETE_POST, {\n    variables: { id: postId },\n    optimisticResponse: {\n      deletePost: {\n        __typename: "Post",\n        id: postId,\n      },\n    },\n    update: (cache) => {\n      // Remove from cache immediately\n      cache.evict({ id: cache.identify({ __typename: "Post", id: postId }) });\n      cache.gc(); // Garbage collect orphaned references\n    },\n  });\n\n  return <button onClick={() => deletePost()}>Delete Post</button>;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"subscriptions-real-time-updates",children:"Subscriptions (Real-time Updates)"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// subscriptions/messages.ts\nimport { gql } from "@apollo/client";\n\nexport const MESSAGE_ADDED = gql`\n  subscription MessageAdded($chatId: ID!) {\n    messageAdded(chatId: $chatId) {\n      id\n      content\n      user {\n        id\n        name\n        avatar\n      }\n      createdAt\n    }\n  }\n`;\n\nexport const USER_ONLINE_STATUS = gql`\n  subscription UserOnlineStatus {\n    userOnlineStatus {\n      userId\n      isOnline\n      lastSeen\n    }\n  }\n`;\n\n// Component usage\nimport { useSubscription } from "@apollo/client";\n\nfunction ChatRoom({ chatId }) {\n  const { data: messages, loading } = useQuery(GET_MESSAGES, {\n    variables: { chatId },\n  });\n\n  // Subscribe to new messages\n  const { data: newMessage } = useSubscription(MESSAGE_ADDED, {\n    variables: { chatId },\n    onSubscriptionData: ({ client, subscriptionData }) => {\n      // Update cache when new message arrives\n      client.cache.modify({\n        fields: {\n          messages(existingMessages = []) {\n            const newMessageRef = client.cache.writeFragment({\n              data: subscriptionData.data.messageAdded,\n              fragment: gql`\n                fragment NewMessage on Message {\n                  id\n                  content\n                  user {\n                    id\n                    name\n                    avatar\n                  }\n                  createdAt\n                }\n              `,\n            });\n            return [...existingMessages, newMessageRef];\n          },\n        },\n      });\n    },\n  });\n\n  if (loading) return <div>Loading messages...</div>;\n\n  return (\n    <div>\n      {messages?.messages.map((message) => (\n        <div key={message.id}>\n          <strong>{message.user.name}:</strong> {message.content}\n        </div>\n      ))}\n    </div>\n  );\n}\n\n// Multiple subscriptions\nfunction OnlineUsers() {\n  const { data } = useSubscription(USER_ONLINE_STATUS, {\n    onSubscriptionData: ({ client, subscriptionData }) => {\n      const { userId, isOnline, lastSeen } =\n        subscriptionData.data.userOnlineStatus;\n\n      // Update user\'s online status in cache\n      client.cache.modify({\n        id: client.cache.identify({ __typename: "User", id: userId }),\n        fields: {\n          isOnline: () => isOnline,\n          lastSeen: () => lastSeen,\n        },\n      });\n    },\n  });\n\n  return <div>Real-time online status updates</div>;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// Global error handling\nimport { onError } from "@apollo/client/link/error";\n\nconst errorLink = onError(\n  ({ graphQLErrors, networkError, operation, forward }) => {\n    if (graphQLErrors) {\n      graphQLErrors.forEach(({ message, locations, path }) => {\n        console.log(\n          `GraphQL error: Message: ${message}, Location: ${locations}, Path: ${path}`\n        );\n      });\n    }\n\n    if (networkError) {\n      console.log(`Network error: ${networkError}`);\n\n      // Handle authentication errors\n      if (networkError.statusCode === 401) {\n        localStorage.removeItem("token");\n        window.location.href = "/login";\n      }\n    }\n  }\n);\n\n// Component-level error handling\nfunction UserProfile({ userId }) {\n  const { data, loading, error, refetch } = useQuery(GET_USER, {\n    variables: { id: userId },\n    errorPolicy: "all", // Return partial data even with errors\n    notifyOnNetworkStatusChange: true,\n  });\n\n  // Custom error boundary\n  if (error) {\n    return (\n      <div className="error-container">\n        <h3>Something went wrong</h3>\n        <p>{error.message}</p>\n        <button onClick={() => refetch()}>Try Again</button>\n\n        {/* Show partial data if available */}\n        {data?.user && (\n          <div className="partial-data">\n            <p>Showing cached data:</p>\n            <h4>{data.user.name}</h4>\n          </div>\n        )}\n      </div>\n    );\n  }\n\n  return <div>{/* Normal component rendering */}</div>;\n}\n\n// Mutation error handling\nfunction UpdateUserForm({ userId }) {\n  const [updateUser, { loading, error, reset }] = useMutation(UPDATE_USER, {\n    errorPolicy: "all",\n    onError: (error) => {\n      // Custom error handling\n      if (\n        error.graphQLErrors.some(\n          (e) => e.extensions.code === "VALIDATION_ERROR"\n        )\n      ) {\n        // Handle validation errors\n        setValidationErrors(error.graphQLErrors);\n      }\n    },\n  });\n\n  return (\n    <form>\n      {error && (\n        <div className="error-banner">\n          <p>Failed to update: {error.message}</p>\n          <button onClick={() => reset()}>Dismiss</button>\n        </div>\n      )}\n      {/* form fields */}\n    </form>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"pagination",children:"Pagination"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// Cursor-based pagination\nexport const GET_POSTS = gql`\n  query GetPosts($first: Int, $after: String) {\n    posts(first: $first, after: $after) {\n      edges {\n        node {\n          id\n          title\n          content\n          author {\n            name\n          }\n          createdAt\n        }\n        cursor\n      }\n      pageInfo {\n        hasNextPage\n        hasPreviousPage\n        startCursor\n        endCursor\n      }\n    }\n  }\n`;\n\nfunction PostsList() {\n  const { data, loading, error, fetchMore } = useQuery(GET_POSTS, {\n    variables: { first: 10 },\n    notifyOnNetworkStatusChange: true,\n  });\n\n  const loadMore = () => {\n    if (data?.posts.pageInfo.hasNextPage) {\n      fetchMore({\n        variables: {\n          after: data.posts.pageInfo.endCursor,\n        },\n        updateQuery: (prev, { fetchMoreResult }) => {\n          if (!fetchMoreResult) return prev;\n\n          return {\n            posts: {\n              ...fetchMoreResult.posts,\n              edges: [...prev.posts.edges, ...fetchMoreResult.posts.edges],\n            },\n          };\n        },\n      });\n    }\n  };\n\n  if (loading && !data) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  return (\n    <div>\n      {data?.posts.edges.map(({ node: post }) => (\n        <div key={post.id}>\n          <h3>{post.title}</h3>\n          <p>{post.content}</p>\n          <small>By {post.author.name}</small>\n        </div>\n      ))}\n\n      {data?.posts.pageInfo.hasNextPage && (\n        <button onClick={loadMore} disabled={loading}>\n          {loading ? "Loading..." : "Load More"}\n        </button>\n      )}\n    </div>\n  );\n}\n\n// Offset-based pagination\nexport const GET_USERS_PAGINATED = gql`\n  query GetUsersPaginated($limit: Int, $offset: Int) {\n    users(limit: $limit, offset: $offset) {\n      id\n      name\n      email\n    }\n    userCount\n  }\n`;\n\nfunction PaginatedUsers() {\n  const [page, setPage] = useState(1);\n  const limit = 10;\n  const offset = (page - 1) * limit;\n\n  const { data, loading, error } = useQuery(GET_USERS_PAGINATED, {\n    variables: { limit, offset },\n    fetchPolicy: "cache-and-network",\n  });\n\n  const totalPages = data ? Math.ceil(data.userCount / limit) : 0;\n\n  return (\n    <div>\n      {data?.users.map((user) => (\n        <div key={user.id}>{user.name}</div>\n      ))}\n\n      <div className="pagination">\n        <button onClick={() => setPage((p) => p - 1)} disabled={page === 1}>\n          Previous\n        </button>\n\n        <span>\n          Page {page} of {totalPages}\n        </span>\n\n        <button\n          onClick={() => setPage((p) => p + 1)}\n          disabled={page === totalPages}\n        >\n          Next\n        </button>\n      </div>\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"local-state-management",children:"Local State Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// Local state with Apollo Client\nimport { makeVar } from "@apollo/client";\n\n// Reactive variables\nexport const cartItemsVar = makeVar([]);\nexport const isLoggedInVar = makeVar(false);\nexport const themeVar = makeVar("light");\n\n// Local-only fields in queries\nexport const GET_CART = gql`\n  query GetCart {\n    cartItems @client\n    isLoggedIn @client\n  }\n`;\n\n// Type policies for local state\nconst cache = new InMemoryCache({\n  typePolicies: {\n    Query: {\n      fields: {\n        cartItems: {\n          read() {\n            return cartItemsVar();\n          },\n        },\n        isLoggedIn: {\n          read() {\n            return isLoggedInVar();\n          },\n        },\n      },\n    },\n  },\n});\n\n// Component usage\nfunction ShoppingCart() {\n  const { data } = useQuery(GET_CART);\n\n  const addToCart = (item) => {\n    const currentItems = cartItemsVar();\n    cartItemsVar([...currentItems, item]);\n  };\n\n  const removeFromCart = (itemId) => {\n    const currentItems = cartItemsVar();\n    cartItemsVar(currentItems.filter((item) => item.id !== itemId));\n  };\n\n  return (\n    <div>\n      <h2>Cart ({data?.cartItems?.length || 0})</h2>\n      {data?.cartItems?.map((item) => (\n        <div key={item.id}>\n          {item.name}\n          <button onClick={() => removeFromCart(item.id)}>Remove</button>\n        </div>\n      ))}\n    </div>\n  );\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"cache-management",children:"Cache Management"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// Direct cache manipulation\nfunction CacheExample() {\n  const client = useApolloClient();\n\n  const updateUserInCache = (userId, updates) => {\n    client.cache.modify({\n      id: client.cache.identify({ __typename: "User", id: userId }),\n      fields: {\n        name(existing) {\n          return updates.name || existing;\n        },\n        email(existing) {\n          return updates.email || existing;\n        },\n      },\n    });\n  };\n\n  const removeUserFromCache = (userId) => {\n    client.cache.evict({\n      id: client.cache.identify({ __typename: "User", id: userId }),\n    });\n    client.cache.gc(); // Clean up orphaned references\n  };\n\n  const refetchQueries = () => {\n    client.refetchQueries({\n      include: [GET_USERS, GET_USER],\n    });\n  };\n\n  const resetStore = () => {\n    client.resetStore(); // Clear cache and refetch active queries\n  };\n\n  return <div>Cache management examples</div>;\n}\n\n// Custom fetch policies\nfunction CustomFetchPolicies() {\n  // cache-first: Use cache, fallback to network\n  const { data: cached } = useQuery(GET_USERS, {\n    fetchPolicy: "cache-first",\n  });\n\n  // cache-and-network: Use cache immediately, update from network\n  const { data: fresh } = useQuery(GET_USERS, {\n    fetchPolicy: "cache-and-network",\n  });\n\n  // network-only: Always fetch from network\n  const { data: latest } = useQuery(GET_USERS, {\n    fetchPolicy: "network-only",\n  });\n\n  // no-cache: Fetch from network, don\'t cache result\n  const { data: uncached } = useQuery(GET_USERS, {\n    fetchPolicy: "no-cache",\n  });\n\n  return <div>Different fetch policies</div>;\n}\n'})}),"\n",(0,r.jsx)(n.h2,{id:"developer-tools",children:"Developer Tools"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:'// Install Apollo DevTools browser extension\n// Then inspect your GraphQL operations, cache, and mutations\n\nfunction DebugExample() {\n  const { data, loading, error } = useQuery(GET_USERS, {\n    // Enable dev tools features\n    notifyOnNetworkStatusChange: true,\n    errorPolicy: "all",\n  });\n\n  // DevTools shows:\n  // \u2705 Query execution timeline\n  // \u2705 Cache contents and updates\n  // \u2705 Network requests and responses\n  // \u2705 Mutation results and optimistic updates\n  // \u2705 Schema exploration\n  // \u2705 Query performance metrics\n\n  return <div>Check Apollo DevTools in browser!</div>;\n}\n\n// Enable more detailed logging\nconst client = new ApolloClient({\n  uri: "/graphql",\n  cache: new InMemoryCache(),\n  connectToDevTools: true, // Enable in production for debugging\n  defaultOptions: {\n    watchQuery: {\n      errorPolicy: "all", // Show partial data + errors in DevTools\n    },\n  },\n});\n'})}),"\n",(0,r.jsx)(n.h2,{id:"type-safety-with-code-generation",children:"Type Safety with Code Generation"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-tsx",children:"// Install: npm install -D @graphql-codegen/cli @graphql-codegen/typescript @graphql-codegen/typescript-operations @graphql-codegen/typescript-react-apollo\n\n// codegen.yml\n/*\nschema: \"http://localhost:4000/graphql\"\ndocuments: \"src/**/*.{ts,tsx}\"\ngenerates:\n  src/generated/graphql.ts:\n    plugins:\n      - typescript\n      - typescript-operations\n      - typescript-react-apollo\n    config:\n      withHooks: true\n      withComponent: false\n      withHOC: false\n*/\n\n// Before code generation - no types\nconst GET_USER = gql`\n  query GetUser($id: ID!) {\n    user(id: $id) {\n      id\n      name\n      email\n      posts {\n        id\n        title\n      }\n    }\n  }\n`;\n\nfunction UserProfile({ userId }: { userId: string }) {\n  const { data, loading, error } = useQuery(GET_USER, {\n    variables: { id: userId }\n  });\n\n  // No TypeScript support:\n  // - data is 'any' type\n  // - No autocomplete\n  // - No compile-time error checking\n  // - Typos in field names go unnoticed\n\n  return <div>{data?.user?.name}</div>; // Could be undefined!\n}\n\n// After code generation - full type safety\nimport { useGetUserQuery, GetUserQuery, GetUserQueryVariables } from '../generated/graphql';\n\nfunction TypedUserProfile({ userId }: { userId: string }) {\n  const { data, loading, error } = useGetUserQuery({\n    variables: { id: userId }\n  });\n\n  // Full TypeScript support:\n  // \u2705 data is typed as GetUserQuery | undefined\n  // \u2705 Full autocomplete for all fields\n  // \u2705 Compile-time error checking\n  // \u2705 Typos caught at build time\n  // \u2705 Refactoring safety\n\n  if (loading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n  if (!data?.user) return <div>User not found</div>;\n\n  return (\n    <div>\n      <h1>{data.user.name}</h1> {/* TypeScript knows this exists */}\n      <p>{data.user.email}</p>\n      <div>\n        Posts: {data.user.posts.length} {/* Array operations are typed */}\n        {data.user.posts.map(post => (\n          <div key={post.id}>{post.title}</div> // Full autocomplete\n        ))}\n      </div>\n    </div>\n  );\n}\n\n// Generated types example\nexport type GetUserQuery = {\n  __typename?: 'Query';\n  user?: {\n    __typename?: 'User';\n    id: string;\n    name: string;\n    email: string;\n    posts: Array<{\n      __typename?: 'Post';\n      id: string;\n      title: string;\n    }>;\n  } | null;\n};\n\nexport type GetUserQueryVariables = {\n  id: string;\n};\n\n// Typed mutations\nimport { useCreateUserMutation, CreateUserInput } from '../generated/graphql';\n\nfunction CreateUserForm() {\n  const [createUser, { loading, error }] = useCreateUserMutation();\n\n  const handleSubmit = async (formData: CreateUserInput) => {\n    try {\n      const { data } = await createUser({\n        variables: { input: formData } // TypeScript validates input shape\n      });\n\n      // data.createUser is fully typed\n      console.log('Created user:', data?.createUser?.name);\n    } catch (err) {\n      // Error handling\n    }\n  };\n\n  return <form onSubmit={handleSubmit}>{/* form fields */}</form>;\n}\n\n// Fragment types for reusability\nimport { UserFragmentFragment } from '../generated/graphql';\n\nconst USER_FRAGMENT = gql`\n  fragment UserFragment on User {\n    id\n    name\n    email\n    avatar\n  }\n`;\n\nfunction UserCard({ user }: { user: UserFragmentFragment }) {\n  // user parameter is fully typed from the fragment\n  return (\n    <div>\n      <img src={user.avatar} alt={user.name} />\n      <h3>{user.name}</h3>\n      <p>{user.email}</p>\n    </div>\n  );\n}\n"})})]})}function u(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(6540);const r={},s=a.createContext(r);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);