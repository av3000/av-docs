"use strict";(self.webpackChunkav_docusaurus_classic=self.webpackChunkav_docusaurus_classic||[]).push([[1978],{2279:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>r,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"frontend/react/state-management/xstate","title":"[XState](https://xstate.js.org/)","description":"stately.ai/docs","source":"@site/docs/frontend/react/state-management/xstate.md","sourceDirName":"frontend/react/state-management","slug":"/frontend/react/state-management/xstate","permalink":"/av-docs/docs/frontend/react/state-management/xstate","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/frontend/react/state-management/xstate.md","tags":[],"version":"current","frontMatter":{"sidebar_label":"XState"},"sidebar":"frontendSidebar","previous":{"title":"Redux","permalink":"/av-docs/docs/frontend/react/state-management/redux"},"next":{"title":"useEffect","permalink":"/av-docs/docs/frontend/react/useEffect"}}');var a=t(4848),i=t(8453);const o={sidebar_label:"XState"},r="XState",c={},l=[{value:"Why State Machines over useState/useReducer?",id:"why-state-machines-over-usestateusereducer",level:2},{value:"Key Benefits",id:"key-benefits",level:2},{value:"The useState Problem - Impossible States",id:"the-usestate-problem---impossible-states",level:3},{value:"XState Solution - Explicit States",id:"xstate-solution---explicit-states",level:3},{value:"Basic Setup",id:"basic-setup",level:2},{value:"Simple State Machine",id:"simple-state-machine",level:2},{value:"State Machine with Context (Data)",id:"state-machine-with-context-data",level:2},{value:"Guards (Conditional Transitions)",id:"guards-conditional-transitions",level:2},{value:"Async Operations (Promises)",id:"async-operations-promises",level:2},{value:"Hierarchical States (Nested)",id:"hierarchical-states-nested",level:2},{value:"Parallel States",id:"parallel-states",level:2},{value:"Key XState Hooks",id:"key-xstate-hooks",level:2}];function d(n){const e={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.header,{children:(0,a.jsx)(e.h1,{id:"xstate",children:(0,a.jsx)(e.a,{href:"https://xstate.js.org/",children:"XState"})})}),"\n",(0,a.jsx)(e.p,{children:(0,a.jsx)(e.a,{href:"https://stately.ai/docs",children:"stately.ai/docs"})}),"\n",(0,a.jsx)(e.p,{children:"XState is a state management and orchestration solution for JavaScript and TypeScript apps. It has zero dependencies, and is useful for frontend and backend application logic."}),"\n",(0,a.jsx)(e.p,{children:"It uses event-driven programming, state machines, statecharts, and the actor model to handle complex logic in predictable, robust, and visual ways. XState provides a powerful and flexible way to manage application and workflow state by allowing developers to model logic as actors and state machines."}),"\n",(0,a.jsx)(e.h2,{id:"why-state-machines-over-usestateusereducer",children:"Why State Machines over useState/useReducer?"}),"\n",(0,a.jsxs)(e.p,{children:["Traditional state management with ",(0,a.jsx)(e.code,{children:"useState"})," or ",(0,a.jsx)(e.code,{children:"useReducer"})," allows ",(0,a.jsx)(e.strong,{children:"impossible states"})," and unpredictable transitions. State machines make states explicit and transitions predictable, preventing bugs from invalid state combinations."]}),"\n",(0,a.jsx)(e.h2,{id:"key-benefits",children:"Key Benefits"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Impossible states eliminated"}),": Only valid state combinations possible"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Predictable transitions"}),": Clear rules for state changes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Visual documentation"}),": State charts serve as living documentation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Better testing"}),": Test state transitions, not implementation details"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Complex async flows"}),": Built-in support for promises, timeouts, cancellation"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Hierarchical organization"}),": Nested states for complex UIs"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Parallel states"}),": Multiple independent state machines running together"]}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"the-usestate-problem---impossible-states",children:"The useState Problem - Impossible States"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'// Problem: Multiple booleans create impossible states\nfunction LoginForm() {\n  const [isLoading, setIsLoading] = useState(false);\n  const [isSuccess, setIsSuccess] = useState(false);\n  const [isError, setIsError] = useState(false);\n  const [errorMessage, setErrorMessage] = useState("");\n\n  // What if isLoading=true AND isSuccess=true?\n  // What if isError=true but errorMessage is empty?\n  // 16 possible combinations, most are invalid!\n\n  const handleSubmit = async () => {\n    setIsLoading(true);\n    setIsError(false); // Easy to forget resetting\n    setIsSuccess(false); // Easy to forget resetting\n\n    try {\n      await login();\n      setIsLoading(false);\n      setIsSuccess(true);\n      // Forgot to reset error state - bug!\n    } catch (error) {\n      setIsLoading(false);\n      setIsError(true);\n      setErrorMessage(error.message);\n      // What if we forgot setIsSuccess(false)?\n    }\n  };\n}\n'})}),"\n",(0,a.jsx)(e.h3,{id:"xstate-solution---explicit-states",children:"XState Solution - Explicit States"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'// Solution: Only valid states are possible\nconst loginMachine = createMachine({\n  id: "login",\n  initial: "idle",\n  states: {\n    idle: {\n      on: { SUBMIT: "loading" },\n    },\n    loading: {\n      on: {\n        SUCCESS: "success",\n        ERROR: "error",\n      },\n    },\n    success: {\n      on: { RESET: "idle" },\n    },\n    error: {\n      on: {\n        RETRY: "loading",\n        RESET: "idle",\n      },\n    },\n  },\n});\n\n// Only 4 possible states - all valid!\n// Transitions are explicit and predictable\n'})}),"\n",(0,a.jsx)(e.h2,{id:"basic-setup",children:"Basic Setup"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'// Install: npm install xstate @xstate/react\n\nimport { createMachine } from "xstate";\nimport { useMachine } from "@xstate/react";\n'})}),"\n",(0,a.jsx)(e.h2,{id:"simple-state-machine",children:"Simple State Machine"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'// machines/toggle.ts\nimport { createMachine } from "xstate";\n\nexport const toggleMachine = createMachine({\n  id: "toggle",\n  initial: "off",\n  states: {\n    off: {\n      on: {\n        TOGGLE: "on",\n      },\n    },\n    on: {\n      on: {\n        TOGGLE: "off",\n      },\n    },\n  },\n});\n\n// Component usage\nimport { useMachine } from "@xstate/react";\n\nfunction ToggleSwitch() {\n  const [state, send] = useMachine(toggleMachine);\n\n  return (\n    <div>\n      <p>Switch is: {state.value}</p>\n      <button onClick={() => send("TOGGLE")}>\n        Turn {state.value === "off" ? "On" : "Off"}\n      </button>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"state-machine-with-context-data",children:"State Machine with Context (Data)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'// machines/counter.ts\nimport { createMachine, assign } from "xstate";\n\ninterface CounterContext {\n  count: number;\n  step: number;\n}\n\nexport const counterMachine = createMachine({\n  id: "counter",\n  initial: "active",\n  context: {\n    count: 0,\n    step: 1,\n  } as CounterContext,\n  states: {\n    active: {\n      on: {\n        INCREMENT: {\n          actions: assign({\n            count: (context) => context.count + context.step,\n          }),\n        },\n        DECREMENT: {\n          actions: assign({\n            count: (context) => context.count - context.step,\n          }),\n        },\n        SET_STEP: {\n          actions: assign({\n            step: (_, event) => event.value,\n          }),\n        },\n        RESET: {\n          actions: assign({\n            count: 0,\n          }),\n        },\n      },\n    },\n  },\n});\n\n// Component usage\nfunction Counter() {\n  const [state, send] = useMachine(counterMachine);\n  const { count, step } = state.context;\n\n  return (\n    <div>\n      <p>\n        Count: {count} (Step: {step})\n      </p>\n      <button onClick={() => send("INCREMENT")}>+</button>\n      <button onClick={() => send("DECREMENT")}>-</button>\n      <button onClick={() => send({ type: "SET_STEP", value: 5 })}>\n        Set Step to 5\n      </button>\n      <button onClick={() => send("RESET")}>Reset</button>\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"guards-conditional-transitions",children:"Guards (Conditional Transitions)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'// machines/auth.ts\nimport { createMachine, assign } from "xstate";\n\ninterface AuthContext {\n  user: string;\n  password: string;\n  attempts: number;\n  maxAttempts: number;\n}\n\nexport const authMachine = createMachine(\n  {\n    id: "auth",\n    initial: "idle",\n    context: {\n      user: "",\n      password: "",\n      attempts: 0,\n      maxAttempts: 3,\n    } as AuthContext,\n    states: {\n      idle: {\n        on: {\n          SUBMIT: {\n            target: "checking",\n            cond: "hasCredentials", // Guard condition\n          },\n          UPDATE_FIELD: {\n            actions: assign({\n              user: (context, event) =>\n                event.field === "user" ? event.value : context.user,\n              password: (context, event) =>\n                event.field === "password" ? event.value : context.password,\n            }),\n          },\n        },\n      },\n      checking: {\n        on: {\n          SUCCESS: "authenticated",\n          FAILURE: [\n            {\n              target: "locked",\n              cond: "maxAttemptsReached",\n              actions: assign({ attempts: (context) => context.attempts + 1 }),\n            },\n            {\n              target: "idle",\n              actions: assign({ attempts: (context) => context.attempts + 1 }),\n            },\n          ],\n        },\n      },\n      authenticated: {\n        on: {\n          LOGOUT: "idle",\n        },\n      },\n      locked: {\n        on: {\n          RESET: {\n            target: "idle",\n            actions: assign({ attempts: 0 }),\n          },\n        },\n      },\n    },\n  },\n  {\n    guards: {\n      hasCredentials: (context) =>\n        context.user.length > 0 && context.password.length > 0,\n      maxAttemptsReached: (context) =>\n        context.attempts >= context.maxAttempts - 1,\n    },\n  }\n);\n'})}),"\n",(0,a.jsx)(e.h2,{id:"async-operations-promises",children:"Async Operations (Promises)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'// machines/dataFetcher.ts\nimport { createMachine, assign } from "xstate";\n\ninterface DataContext {\n  data: any[];\n  error: string | null;\n}\n\nexport const dataFetcherMachine = createMachine(\n  {\n    id: "dataFetcher",\n    initial: "idle",\n    context: {\n      data: [],\n      error: null,\n    } as DataContext,\n    states: {\n      idle: {\n        on: {\n          FETCH: "loading",\n        },\n      },\n      loading: {\n        invoke: {\n          id: "fetchData",\n          src: "fetchDataService",\n          onDone: {\n            target: "success",\n            actions: assign({\n              data: (_, event) => event.data,\n              error: null,\n            }),\n          },\n          onError: {\n            target: "failure",\n            actions: assign({\n              error: (_, event) => event.data.message,\n              data: [],\n            }),\n          },\n        },\n        on: {\n          CANCEL: "idle",\n        },\n      },\n      success: {\n        on: {\n          FETCH: "loading",\n          REFRESH: "loading",\n        },\n      },\n      failure: {\n        on: {\n          RETRY: "loading",\n          RESET: "idle",\n        },\n      },\n    },\n  },\n  {\n    services: {\n      fetchDataService: async () => {\n        const response = await fetch("/api/data");\n        if (!response.ok) throw new Error("Failed to fetch");\n        return response.json();\n      },\n    },\n  }\n);\n\n// Component usage\nfunction DataFetcher() {\n  const [state, send] = useMachine(dataFetcherMachine);\n  const { data, error } = state.context;\n\n  return (\n    <div>\n      <button onClick={() => send("FETCH")} disabled={state.matches("loading")}>\n        {state.matches("loading") ? "Loading..." : "Fetch Data"}\n      </button>\n\n      {state.matches("loading") && (\n        <button onClick={() => send("CANCEL")}>Cancel</button>\n      )}\n\n      {state.matches("success") && (\n        <div>\n          <p>Data loaded: {data.length} items</p>\n          <button onClick={() => send("REFRESH")}>Refresh</button>\n        </div>\n      )}\n\n      {state.matches("failure") && (\n        <div>\n          <p>Error: {error}</p>\n          <button onClick={() => send("RETRY")}>Retry</button>\n          <button onClick={() => send("RESET")}>Reset</button>\n        </div>\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"hierarchical-states-nested",children:"Hierarchical States (Nested)"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'// machines/player.ts - Music player with nested states\nimport { createMachine } from "xstate";\n\nexport const playerMachine = createMachine({\n  id: "player",\n  initial: "stopped",\n  states: {\n    stopped: {\n      on: {\n        PLAY: "playing",\n      },\n    },\n    playing: {\n      initial: "normal", // Default nested state\n      states: {\n        normal: {\n          on: {\n            SHUFFLE_ON: "shuffled",\n          },\n        },\n        shuffled: {\n          on: {\n            SHUFFLE_OFF: "normal",\n          },\n        },\n      },\n      on: {\n        PAUSE: "paused",\n        STOP: "stopped",\n      },\n    },\n    paused: {\n      on: {\n        PLAY: "playing",\n        STOP: "stopped",\n      },\n    },\n  },\n});\n\n// Component usage\nfunction MusicPlayer() {\n  const [state, send] = useMachine(playerMachine);\n\n  return (\n    <div>\n      <p>Player: {state.value}</p>\n\n      {/* Check nested states */}\n      {state.matches("playing") && (\n        <p>Mode: {state.matches("playing.shuffled") ? "Shuffle" : "Normal"}</p>\n      )}\n\n      <button onClick={() => send("PLAY")}>Play</button>\n      <button onClick={() => send("PAUSE")}>Pause</button>\n      <button onClick={() => send("STOP")}>Stop</button>\n\n      {state.matches("playing") && (\n        <>\n          <button onClick={() => send("SHUFFLE_ON")}>Shuffle On</button>\n          <button onClick={() => send("SHUFFLE_OFF")}>Shuffle Off</button>\n        </>\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"parallel-states",children:"Parallel States"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'// machines/app.ts - App with independent features\nimport { createMachine } from "xstate";\n\nexport const appMachine = createMachine({\n  id: "app",\n  type: "parallel", // Multiple states active simultaneously\n  states: {\n    auth: {\n      initial: "loggedOut",\n      states: {\n        loggedOut: {\n          on: { LOGIN: "loggedIn" },\n        },\n        loggedIn: {\n          on: { LOGOUT: "loggedOut" },\n        },\n      },\n    },\n    theme: {\n      initial: "light",\n      states: {\n        light: {\n          on: { TOGGLE_THEME: "dark" },\n        },\n        dark: {\n          on: { TOGGLE_THEME: "light" },\n        },\n      },\n    },\n    sidebar: {\n      initial: "closed",\n      states: {\n        closed: {\n          on: { OPEN_SIDEBAR: "open" },\n        },\n        open: {\n          on: { CLOSE_SIDEBAR: "closed" },\n        },\n      },\n    },\n  },\n});\n\n// Component usage\nfunction App() {\n  const [state, send] = useMachine(appMachine);\n\n  return (\n    <div className={state.matches({ theme: "dark" }) ? "dark" : "light"}>\n      <header>\n        <button onClick={() => send("TOGGLE_THEME")}>\n          {state.matches({ theme: "dark" }) ? "\u2600\ufe0f" : "\ud83c\udf19"}\n        </button>\n\n        {state.matches({ auth: "loggedOut" }) ? (\n          <button onClick={() => send("LOGIN")}>Login</button>\n        ) : (\n          <button onClick={() => send("LOGOUT")}>Logout</button>\n        )}\n\n        <button onClick={() => send("OPEN_SIDEBAR")}>\u2630</button>\n      </header>\n\n      {state.matches({ sidebar: "open" }) && (\n        <aside>\n          <button onClick={() => send("CLOSE_SIDEBAR")}>\xd7</button>\n          <p>Sidebar content</p>\n        </aside>\n      )}\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(e.h2,{id:"key-xstate-hooks",children:"Key XState Hooks"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-tsx",children:'import { useMachine, useActor, useSelector } from "@xstate/react";\n\nfunction HookExamples() {\n  // Full machine access\n  const [state, send] = useMachine(myMachine);\n\n  // Subscribe to specific state value\n  const isLoading = useSelector(myService, (state) => state.matches("loading"));\n\n  // Use existing service/actor\n  const [state, send] = useActor(existingService);\n\n  return <div>{/* Your component */}</div>;\n}\n'})})]})}function u(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(d,{...n})}):d(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>o,x:()=>r});var s=t(6540);const a={},i=s.createContext(a);function o(n){const e=s.useContext(i);return s.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(a):n.components||a:o(n.components),s.createElement(i.Provider,{value:e},n.children)}}}]);